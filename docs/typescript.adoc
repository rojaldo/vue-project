= Curso de TypeScript
:icons: font
:toc: left
:toclevels: 2

== Módulo 1: Introducción a TypeScript

=== Qué es TypeScript y por qué utilizarlo
TypeScript es un lenguaje de programación que extiende JavaScript agregando tipos estáticos. Permite detectar errores durante el desarrollo, lo que ayuda a mejorar la calidad del código y facilita el mantenimiento en proyectos grandes. 

.TypeScript es útil para:
- Evitar errores comunes de tipo en JavaScript
- Mejorar la legibilidad y documentación del código
- Hacer el desarrollo más productivo y seguro en aplicaciones complejas

=== Instalación y configuración básica

.Para instalar TypeScript, necesitas tener Node.js y npm (Node Package Manager) instalados. La instalación global se realiza con el siguiente comando:
[source, bash]
----
npm install -g typescript
----

.Una vez instalado, puedes verificar la versión con:
[source, bash]
----
tsc --version
----

=== Configuración de proyectos con `tsconfig.json`

.El archivo `tsconfig.json` permite configurar el compilador TypeScript y personalizar el comportamiento del proyecto. Puedes crear este archivo con:
[source, bash]
----
tsc --init
----
Dentro del archivo `tsconfig.json`, puedes ajustar opciones importantes como `target`, `module`, y `strict` para adaptar la compilación a las necesidades del proyecto.

=== Primeros pasos: el primer programa en TypeScript
.Crea un archivo `index.ts` y añade el siguiente código para probar TypeScript:
[source, typescript]
----
function greet(name: string): string {
    return `Hello, ${name}!`;
}

console.log(greet("TypeScript"));
----
.Para compilarlo, usa el comando:
[source, bash]
----
tsc index.ts
----
.Esto generará un archivo `index.js` que puedes ejecutar con Node.js:
[source, bash]
----
node index.js
----

=== Diferencias clave entre TypeScript y JavaScript
1. **Tipado estático**: TypeScript permite definir tipos para variables y funciones, mientras que JavaScript usa tipado dinámico.
2. **Interfaces y tipos**: TypeScript introduce interfaces y tipos personalizados para modelar estructuras de datos complejas.
3. **Compilación**: TypeScript se compila a JavaScript, lo que implica un paso adicional antes de ejecutar el código.
4. **Compatibilidad con versiones antiguas**: TypeScript permite definir el nivel de compatibilidad con ECMAScript a través de `tsconfig.json`.

Con estas bases, estás listo para comenzar a explorar TypeScript y sus características avanzadas.

== Módulo 2: Tipos básicos

=== Tipos primitivos (`string`, `number`, `boolean`, `null`, `undefined`)
.TypeScript proporciona tipos primitivos similares a JavaScript, con la ventaja de que se pueden definir explícitamente:
[source, typescript]
----
let nombre: string = "Alice";
let edad: number = 30;
let activo: boolean = true;
let indefinido: undefined = undefined;
let nulo: null = null;
----
Estos tipos mejoran la claridad y ayudan al compilador a detectar posibles errores antes de la ejecución.

=== `any`, `unknown`, `never`: Cuándo y cómo usarlos
.**`any`**: Usar este tipo cuando una variable puede tener cualquier valor. Sin embargo, su uso debe ser limitado, ya que desactiva el control de tipos.
[source, typescript]
----
let valor: any = "Puede ser cualquier cosa";
----
.**`unknown`**: Similar a `any`, pero requiere una verificación de tipo antes de ser asignado a otros tipos, lo que es más seguro.
[source, typescript]
----
let dato: unknown = 10;
if (typeof dato === "number") {
    let numero: number = dato;
}
----
.**`never`**: Representa un valor que nunca ocurre, como en funciones que lanzan errores o tienen bucles infinitos.
[source, typescript]
----
function error(mensaje: string): never {
    throw new Error(mensaje);
}
----

=== Arrays y tuplas
.**Arrays**: Se puede definir un array especificando el tipo de elementos que contiene.
[source, typescript]
----
let listaNumeros: number[] = [1, 2, 3, 4];
----
.**Tuplas**: Permiten definir un array con un número fijo de elementos de tipos específicos en un orden concreto.
[source, typescript]
----
let persona: [string, number] = ["Alice", 30];
----

=== Tipos de enumeración (`enum`)
.Los `enum` se utilizan para definir un conjunto de valores constantes con nombres. Son útiles para variables que pueden tener un conjunto limitado de valores.
[source, typescript]
----
enum Color {
    Rojo,
    Verde,
    Azul
}

let colorFavorito: Color = Color.Verde;
----
.Se pueden inicializar con valores personalizados si es necesario:
[source, typescript]
----
enum Estado {
    Activo = 1,
    Inactivo = 0
}
----

=== Tipos de unión y tipos literales
.**Tipos de unión**: Permiten definir una variable que puede ser de más de un tipo.
[source, typescript]
----
let id: number | string = 123;
id = "ABC";
----
.**Tipos literales**: Restringen una variable a ciertos valores específicos, útiles para garantizar valores limitados.
[source, typescript]
----
type EstadoUsuario = "Activo" | "Inactivo" | "Pendiente";
let estado: EstadoUsuario = "Activo";
----
Los tipos de unión y literales permiten mayor control sobre los valores permitidos en una variable, mejorando la seguridad y la claridad del código.

== Módulo 3: Funciones en TypeScript

=== Declaración de funciones y anotaciones de tipo
.En TypeScript, puedes declarar funciones y definir el tipo de los parámetros y el tipo de retorno. Esto permite que el compilador verifique que se usen correctamente.
[source, typescript]
----
function sumar(a: number, b: number): number {
    return a + b;
}
----
Aquí, `a` y `b` deben ser números, y la función debe retornar un número.

=== Parámetros opcionales y valores por defecto
.Los parámetros opcionales se indican con `?`, permitiendo que se omitan al llamar la función. También puedes definir valores por defecto.
[source, typescript]
----
function saludo(nombre: string, saludoFormal?: boolean): string {
    return saludoFormal ? `Buenos días, ${nombre}` : `Hola, ${nombre}`;
}

function incrementar(base: number, incremento: number = 1): number {
    return base + incremento;
}
----
En `saludo`, el parámetro `saludoFormal` es opcional. En `incrementar`, `incremento` tiene un valor por defecto de `1`.

=== Sobrecarga de funciones
.La sobrecarga permite definir múltiples firmas para una misma función, que puede comportarse de manera distinta según los tipos de los argumentos.
[source, typescript]
----
function combinar(a: string, b: string): string;
function combinar(a: number, b: number): number;
function combinar(a: any, b: any): any {
    return a + b;
}
----
En este ejemplo, `combinar` puede sumar números o concatenar cadenas.

=== Funciones como tipos y funciones anónimas
.Puedes usar tipos para definir la estructura de una función y luego asignarla a una variable o usar funciones anónimas.
[source, typescript]
----
type Operacion = (x: number, y: number) => number;
let multiplicar: Operacion = (a, b) => a * b;
----
Aquí, `Operacion` define el tipo de una función que toma dos números y retorna un número.

=== Tipo `this` en funciones
.TypeScript permite especificar el tipo de `this` en funciones, lo que es útil en métodos que usan `this`.
[source, typescript]
----
interface Usuario {
    nombre: string;
    mostrarNombre(this: Usuario): void;
}

let usuario: Usuario = {
    nombre: "Alice",
    mostrarNombre() {
        console.log(this.nombre);
    }
};
usuario.mostrarNombre();
----
El tipo `this: Usuario` asegura que `mostrarNombre` solo puede ser llamado en un contexto donde `this` es del tipo `Usuario`.

Estas características de funciones en TypeScript mejoran la robustez del código y aseguran que los errores comunes sean detectados durante la compilación.

== Módulo 4: Interfaces y tipos avanzados

=== Definición y uso de interfaces
Las interfaces en TypeScript definen la estructura de un objeto, permitiendo especificar propiedades y sus tipos. Son útiles para modelar datos y asegurar que los objetos cumplan ciertas .condiciones.
[source, typescript]
----
interface Persona {
    nombre: string;
    edad: number;
}

function mostrarPersona(persona: Persona): void {
    console.log(`${persona.nombre} tiene ${persona.edad} años`);
}

let persona: Persona = { nombre: "Alice", edad: 30 };
mostrarPersona(persona);
----
Aquí, `Persona` define que un objeto debe tener propiedades `nombre` y `edad`.

=== Extensión de interfaces
.Una interfaz puede extender otra para reutilizar propiedades y métodos. Esto permite crear jerarquías de tipos y extender estructuras de datos.
[source, typescript]
----
interface Trabajador extends Persona {
    puesto: string;
}

let empleado: Trabajador = { nombre: "Bob", edad: 25, puesto: "Desarrollador" };
----
La interfaz `Trabajador` extiende `Persona` y añade la propiedad `puesto`.

=== Tipos compuestos (`type` vs `interface`)
.TypeScript permite definir tipos personalizados mediante `type`. Aunque `type` y `interface` son similares, `type` es más flexible y permite combinaciones avanzadas.
[source, typescript]
----
type ID = string | number;
type PersonaConID = Persona & { id: ID };
----
Aquí, `PersonaConID` es una combinación (intersección) de `Persona` y un objeto con una propiedad `id` que puede ser `string` o `number`.

| Diferencias clave |
|-------------------|
| `interface` permite extensión mediante `extends`, mientras que `type` no |
| `type` permite definir uniones de tipos y combinaciones complejas |
| `interface` es más adecuado para describir objetos o clases estructuradas |

=== Clases y polimorfismo
.Las clases en TypeScript permiten la programación orientada a objetos, proporcionando encapsulamiento, herencia y polimorfismo. Las clases pueden implementar una o varias interfaces.
[source, typescript]
----
interface SerVivo {
    respirar(): void;
}

class Animal implements SerVivo {
    respirar() {
        console.log("Respirando...");
    }
}

class Perro extends Animal {
    ladrar() {
        console.log("Guau!");
    }
}

let mascota: Animal = new Perro();
mascota.respirar(); // Aplica polimorfismo
----
`Perro` extiende `Animal` y añade un método `ladrar`. `mascota` es de tipo `Animal`, pero apunta a una instancia de `Perro`, mostrando el concepto de polimorfismo.

=== Uso de `readonly` y modificadores de acceso (`public`, `private`, `protected`)
.**`readonly`**: Las propiedades `readonly` solo pueden asignarse durante la inicialización o en el constructor, evitando modificaciones posteriores.
[source, typescript]
----
class Libro {
    readonly titulo: string;
    constructor(titulo: string) {
        this.titulo = titulo;
    }
}
----
- **`public`**, **`private`**, y **`protected`**: Estos modificadores controlan el acceso a las propiedades y métodos de una clase.
    - `public`: accesible desde cualquier lugar.
    - `private`: accesible solo dentro de la clase.
    - `protected`: accesible en la clase y en sus subclases.
.
[source, typescript]
----
class Cuenta {
    public nombre: string;
    private saldo: number;
    protected limite: number;

    constructor(nombre: string, saldo: number, limite: number) {
        this.nombre = nombre;
        this.saldo = saldo;
        this.limite = limite;
    }

    private calcularInteres(): number {
        return this.saldo * 0.05;
    }
}
----
Aquí, `nombre` es accesible desde cualquier parte; `saldo` solo dentro de la clase `Cuenta`; y `limite` dentro de `Cuenta` y sus subclases. Estos modificadores permiten encapsular la lógica y proteger los datos sensibles de las clases.

== Módulo 5: Tipos Genéricos

=== Introducción a los tipos genéricos
.Los tipos genéricos permiten que componentes como funciones, clases e interfaces trabajen con varios tipos en lugar de uno específico. Esto permite que el código sea reutilizable y flexible.
[source, typescript]
----
function identidad<T>(valor: T): T {
    return valor;
}

console.log(identidad<string>("Hola"));
console.log(identidad<number>(123));
----
En este ejemplo, `T` es un tipo genérico que se define en tiempo de ejecución, permitiendo que `identidad` acepte y retorne el tipo proporcionado.

=== Funciones genéricas
.Las funciones genéricas se definen con un parámetro de tipo y pueden aceptar distintos tipos en cada invocación.
[source, typescript]
----
function combinar<T, U>(a: T, b: U): [T, U] {
    return [a, b];
}

console.log(combinar<number, string>(1, "TypeScript"));
----
Aquí, `combinar` toma dos tipos `T` y `U` y retorna una tupla con ambos tipos.

=== Clases genéricas
.Las clases genéricas permiten trabajar con propiedades de diferentes tipos en la misma estructura. Esto es útil para estructuras de datos como listas o pilas.
[source, typescript]
----
class Caja<T> {
    contenido: T;
    constructor(contenido: T) {
        this.contenido = contenido;
    }
}

let cajaDeNumeros = new Caja<number>(123);
let cajaDeTexto = new Caja<string>("texto");
----
`Caja` es una clase genérica que puede almacenar diferentes tipos de contenido según el tipo especificado en la instanciación.

=== Interfaces genéricas y restricciones de tipo
.Las interfaces también pueden ser genéricas, lo que permite describir estructuras más versátiles. Además, es posible restringir el tipo genérico usando `extends`.
[source, typescript]
----
interface Par<T> {
    primero: T;
    segundo: T;
}

let numeros: Par<number> = { primero: 1, segundo: 2 };

interface TieneLongitud {
    length: number;
}

function mostrarLongitud<T extends TieneLongitud>(elemento: T): number {
    return elemento.length;
}

console.log(mostrarLongitud("cadena")); // Funciona porque `string` tiene `length`
----
En el ejemplo, `Par` es una interfaz genérica que requiere que `primero` y `segundo` sean del mismo tipo `T`. `mostrarLongitud` usa `extends` para restringir `T` a tipos que tengan la propiedad `length`.

=== Tipos condicionales y tipos mapeados
.**Tipos condicionales**: Permiten crear tipos condicionales que se evalúan en tiempo de compilación. Se usa la sintaxis `T extends U ? X : Y`.
[source, typescript]
----
type EsNumero<T> = T extends number ? "Es un número" : "No es un número";
type Resultado1 = EsNumero<number>; // "Es un número"
type Resultado2 = EsNumero<string>; // "No es un número"
----
.**Tipos mapeados**: Permiten transformar propiedades de un tipo existente en otro tipo, aplicando modificadores de tipo.
[source, typescript]
----
type SoloLectura<T> = {
    readonly [P in keyof T]: T[P];
};

interface Usuario {
    nombre: string;
    edad: number;
}

type UsuarioSoloLectura = SoloLectura<Usuario>;
----
En este ejemplo, `SoloLectura` convierte todas las propiedades de `Usuario` en propiedades de solo lectura.

== Módulo 6: Módulos y espacios de nombres

=== Importación y exportación de módulos
En TypeScript, los módulos ayudan a organizar el código en archivos separados y encapsulan funcionalidades. Para compartir y reutilizar código entre archivos, se usa `export` para declarar lo que se desea exponer y `import` para acceder a esos elementos en otros archivos.
.
[source, typescript]
----
export function saludar(nombre: string): string {
    return `Hola, ${nombre}`;
}
----
Este código exporta la función `saludar`, lo que permite importarla en otro archivo.

=== Uso de `import` y `export` en TypeScript
.Para usar funciones, clases o variables de otros módulos, se usa `import`. El siguiente ejemplo muestra cómo importar `saludar` desde otro archivo:
[source, typescript]
----
import { saludar } from './miModulo';

console.log(saludar("TypeScript"));
----
TypeScript soporta tanto la exportación por defecto (`export default`) como exportaciones nombradas (`export`). La exportación por defecto permite exportar un solo elemento principal en un módulo, que puede ser importado sin llaves `{ }` en el archivo receptor.
.
[source, typescript]
----
export default function despedida(nombre: string): string {
    return `Adiós, ${nombre}`;
}

// Al importar:
import despedida from './miModulo';
console.log(despedida("TypeScript"));
----

=== Configuración de módulos en `tsconfig.json`
El archivo `tsconfig.json` permite configurar cómo TypeScript maneja los módulos en un proyecto. Las opciones comunes para los módulos incluyen:
- `"module": "commonjs"`: para entornos de Node.js.
- `"module": "esnext"`: para aprovechar los módulos nativos en ES6 y navegadores modernos.
- `"outDir"`: define el directorio donde se guardarán los archivos compilados.
  
.Ejemplo básico de configuración de módulos en `tsconfig.json`:
[source, json]
----
{
    "compilerOptions": {
        "module": "commonjs",
        "outDir": "./dist"
    }
}
----

=== Espacios de nombres (namespaces)
Los espacios de nombres (namespaces) son una forma de agrupar código en TypeScript dentro de un mismo archivo o a través de varios archivos. A diferencia de los módulos, los namespaces están pensados para evitar conflictos de nombres en proyectos grandes. 

.Se usan especialmente en aplicaciones que no se dividen en módulos y requieren agrupación lógica de código.
[source, typescript]
----
namespace MiNamespace {
    export function saludar(nombre: string): string {
        return `Hola desde el namespace, ${nombre}`;
    }
}

console.log(MiNamespace.saludar("TypeScript"));
----
Usando `export` dentro del namespace, podemos exponer funciones, clases o variables para acceder a ellas fuera del namespace.

=== Comparación entre módulos y espacios de nombres
|===
| Característica               | Módulos                              | Espacios de Nombres                  

| División de código           | Se basa en archivos                  | Organización dentro de un mismo archivo o varios archivos 

| Uso                          | Import/export entre archivos         | Agrupación lógica sin separación física 

| Compilación                  | Se compilan a archivos separados     | Se mantienen en el mismo archivo en la mayoría de los casos 

| Escenario ideal              | Proyectos modernos y basados en ECMAScript | Proyectos legacy o sin estructura de módulos 
|===


En TypeScript, los módulos son recomendados para la mayoría de los proyectos modernos, especialmente aquellos que utilizan bundlers (como Webpack o esbuild) y módulos ES6. Los namespaces se usan menos en entornos modernos, pero son útiles en ciertos contextos que no requieren la estructura de módulos.

== Módulo 7: Manejo de errores
=== Tipado de errores y `Error` en TypeScript

En TypeScript, los errores pueden ser tipados para proporcionar mayor seguridad y claridad en el manejo de excepciones. La clase base para los errores en JavaScript y TypeScript es `Error`. Podemos extender esta clase para crear errores personalizados.

[source, typescript]
----
class CustomError extends Error {
    constructor(message: string) {
        super(message);
        this.name = "CustomError";
    }
}
----

En el ejemplo anterior, hemos creado una clase `CustomError` que extiende de `Error`. Esto nos permite definir errores específicos para nuestras aplicaciones.

[source, typescript]
----
function throwError(): never {
    throw new CustomError("This is a custom error");
}
----

La función `throwError` lanza una instancia de `CustomError`. El tipo de retorno `never` indica que esta función nunca retorna un valor, ya que siempre lanza una excepción.

[source, typescript]
----
try {
    throwError();
} catch (error) {
    if (error instanceof CustomError) {
        console.error(`Caught a custom error: ${error.message}`);
    } else {
        console.error(`Caught an unknown error: ${error}`);
    }
}
----

=== `try`, `catch`, `finally` y su uso en TypeScript

El manejo de excepciones en TypeScript se realiza de manera similar a JavaScript, utilizando los bloques `try`, `catch` y `finally`. Estos bloques permiten manejar errores de manera controlada y ejecutar código de limpieza independientemente de si se produjo una excepción o no.

[source, typescript]
----
function riskyOperation() {
    if (Math.random() > 0.5) {
        throw new Error("Something went wrong!");
    }
    return "Success!";
}

try {
    const result = riskyOperation();
    console.log(result);
} catch (error) {
    console.error(`Caught an error: ${error.message}`);
} finally {
    console.log("This will always run, regardless of an error.");
}
----

.En el ejemplo anterior:
- El bloque `try` contiene el código que puede lanzar una excepción.
- Si se lanza una excepción, el control pasa al bloque `catch`, donde se puede manejar el error.
- El bloque `finally` se ejecuta siempre, independientemente de si se lanzó una excepción o no. Es útil para realizar tareas de limpieza, como cerrar conexiones o liberar recursos.

== Módulo 8: Integración con JavaScript y Node.js
=== Uso de librerías de JavaScript en TypeScript

TypeScript es compatible con la mayoría de las bibliotecas de JavaScript. Para utilizar una biblioteca de JavaScript en un proyecto TypeScript, es importante contar con los archivos de declaración de tipos (`.d.ts`). Estos archivos proporcionan información de tipo que permite a TypeScript entender cómo interactuar con la biblioteca.

[source, typescript]
----
import * as _ from "lodash";

const numbers: number[] = [1, 2, 3, 4, 5];
const doubledNumbers = _.map(numbers, (num) => num * 2);

console.log(doubledNumbers); // [2, 4, 6, 8, 10]
----

En el ejemplo anterior, utilizamos la biblioteca `lodash` en un proyecto TypeScript. Para que TypeScript reconozca los tipos de `lodash`, necesitamos instalar los tipos correspondientes:

[source, bash]
----
npm install @types/lodash
----

Esto instala los archivos de declaración de tipos para `lodash`, permitiendo que TypeScript proporcione autocompletado y verificación de tipos.

Si una biblioteca no tiene archivos de declaración de tipos disponibles, podemos crear los nuestros o usar el tipo `any` para deshabilitar la verificación de tipos:

[source, typescript]
----
declare module "some-js-library";

import * as someJsLibrary from "some-js-library";

someJsLibrary.doSomething();
----

En este caso, usamos `declare module` para informar a TypeScript que existe un módulo llamado `some-js-library`, aunque no tengamos información de tipos detallada.

=== Archivos de declaración de tipos (`.d.ts`)

Los archivos de declaración de tipos (`.d.ts`) en TypeScript son utilizados para describir la forma de los módulos JavaScript que no están escritos en TypeScript. Estos archivos permiten a TypeScript conocer los tipos de las variables, funciones y clases que están disponibles en un módulo, proporcionando autocompletado y verificación de tipos.

[source, typescript]
----
declare module "my-library" {
    export function myFunction(param: string): number;
    export const myVariable: boolean;
}
----

En el ejemplo anterior, se declara un módulo llamado `my-library` con una función `myFunction` y una variable `myVariable`. Esto permite que TypeScript entienda cómo interactuar con `my-library`.

Para utilizar un archivo de declaración de tipos en un proyecto, simplemente colócalo en un archivo con la extensión `.d.ts` y asegúrate de que esté incluido en el proyecto.

[source, typescript]
----
import { myFunction, myVariable } from "my-library";

const result = myFunction("example");
console.log(result); // Asume que retorna un número

if (myVariable) {
    console.log("myVariable is true");
}
----

Si estás utilizando una biblioteca popular de JavaScript, es probable que ya existan archivos de declaración de tipos disponibles en el repositorio DefinitelyTyped. Puedes instalarlos usando npm:

[source, bash]
----
npm install @types/my-library
----

Esto instalará los archivos de declaración de tipos para `my-library`, permitiendo que TypeScript proporcione autocompletado y verificación de tipos.

=== Configuración de TypeScript en proyectos Node.js

Configurar TypeScript en un proyecto Node.js permite aprovechar las ventajas del tipado estático y las características avanzadas de TypeScript. A continuación se describen los pasos para configurar TypeScript en un proyecto Node.js.

==== 1. Inicializar el proyecto

Primero, inicializa un nuevo proyecto Node.js si aún no lo has hecho:

[source, bash]
----
npm init -y
----

==== 2. Instalar TypeScript

Instala TypeScript y los tipos para Node.js como dependencias de desarrollo:

[source, bash]
----
npm install typescript @types/node --save-dev
----

==== 3. Crear el archivo de configuración de TypeScript

Crea un archivo `tsconfig.json` en la raíz del proyecto para configurar el compilador de TypeScript:

[source, json]
----
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true
    },
    "include": ["src/**/*"]
}
----

Este archivo configura TypeScript para compilar el código en ES6, usar el sistema de módulos CommonJS, y colocar los archivos compilados en el directorio `dist`. También se especifica que los archivos fuente están en el directorio `src`.

==== 4. Escribir código TypeScript

Crea un directorio `src` y escribe tu código TypeScript. Por ejemplo, crea un archivo `src/index.ts`:

[source, typescript]
----
import * as http from "http";

const server = http.createServer((req, res) => {
    res.statusCode = 200;
    res.setHeader("Content-Type", "text/plain");
    res.end("Hello, TypeScript with Node.js!\n");
});

server.listen(3000, () => {
    console.log("Server running at http://localhost:3000/");
});
----

==== 5. Compilar el código TypeScript

Compila el código TypeScript ejecutando el comando `tsc`:

[source, bash]
----
npx tsc
----

Esto generará los archivos JavaScript compilados en el directorio `dist`.

==== 6. Ejecutar el código compilado

Finalmente, ejecuta el código compilado con Node.js:

[source, bash]
----
node dist/index.js
----

Siguiendo estos pasos, habrás configurado TypeScript en tu proyecto Node.js, permitiéndote escribir código más seguro y mantenible.

== Módulo 9: Desarrollo y pruebas en TypeScript
=== Configuración de entornos de prueba para TypeScript

Configurar un entorno de pruebas para TypeScript es esencial para garantizar la calidad y fiabilidad del código. A continuación se describen los pasos para configurar un entorno de pruebas utilizando Jest, una popular biblioteca de pruebas en JavaScript.

==== 1. Inicializar el proyecto

Primero, inicializa un nuevo proyecto Node.js si aún no lo has hecho:

[source, bash]
----
npm init -y
----

==== 2. Instalar Jest y sus tipos

Instala Jest y los tipos para Jest como dependencias de desarrollo:

[source, bash]
----
npm install jest @types/jest ts-jest --save-dev
----

==== 3. Configurar Jest

Crea un archivo de configuración para Jest llamado `jest.config.js` en la raíz del proyecto:

[source, javascript]
----
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts']
};
----

Este archivo configura Jest para usar `ts-jest` como preajuste, lo que permite ejecutar pruebas escritas en TypeScript. También especifica que las pruebas se encuentran en archivos con las extensiones `.spec.ts` o `.test.ts` dentro del directorio `__tests__`.

==== 4. Escribir pruebas en TypeScript

Crea un directorio `__tests__` y escribe tus pruebas en TypeScript. Por ejemplo, crea un archivo `__tests__/sum.test.ts`:

[source, typescript]
----
function sum(a: number, b: number): number {
    return a + b;
}

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
----

==== 5. Ejecutar las pruebas

Ejecuta las pruebas utilizando Jest:

[source, bash]
----
npx jest
----

Jest buscará y ejecutará todas las pruebas definidas en los archivos de prueba.

==== 6. Integrar con TypeScript

Asegúrate de que tu archivo `tsconfig.json` incluya las configuraciones necesarias para las pruebas. Por ejemplo:

[source, json]
----
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true
    },
    "include": ["src/**/*", "__tests__/**/*"]
}
----

Esto asegura que TypeScript compile tanto el código fuente como los archivos de prueba.

=== Pruebas unitarias con Jest y TypeScript

Jest es una popular biblioteca de pruebas en JavaScript que se integra bien con TypeScript. A continuación se describen los pasos para escribir y ejecutar pruebas unitarias con Jest y TypeScript.

==== 1. Inicializar el proyecto

Primero, inicializa un nuevo proyecto Node.js si aún no lo has hecho:

[source, bash]
----
npm init -y
----

==== 2. Instalar Jest y sus tipos

Instala Jest, `ts-jest` y los tipos para Jest como dependencias de desarrollo:

[source, bash]
----
npm install jest @types/jest ts-jest --save-dev
----

==== 3. Configurar Jest

Crea un archivo de configuración para Jest llamado `jest.config.js` en la raíz del proyecto:

[source, javascript]
----
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts']
};
----

Este archivo configura Jest para usar `ts-jest` como preajuste, lo que permite ejecutar pruebas escritas en TypeScript. También especifica que las pruebas se encuentran en archivos con las extensiones `.spec.ts` o `.test.ts` dentro del directorio `__tests__`.

==== 4. Escribir pruebas unitarias en TypeScript

Crea un directorio `__tests__` y escribe tus pruebas unitarias en TypeScript. Por ejemplo, crea un archivo `__tests__/sum.test.ts`:

[source, typescript]
----
function sum(a: number, b: number): number {
    return a + b;
}

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
----

En este ejemplo, se define una función `sum` y se escribe una prueba unitaria para verificar que `sum(1, 2)` retorna `3`.

==== 5. Ejecutar las pruebas

Ejecuta las pruebas utilizando Jest:

[source, bash]
----
npx jest
----

Jest buscará y ejecutará todas las pruebas definidas en los archivos de prueba.

==== 6. Integrar con TypeScript

Asegúrate de que tu archivo `tsconfig.json` incluya las configuraciones necesarias para las pruebas. Por ejemplo:

[source, json]
----
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true
    },
    "include": ["src/**/*", "__tests__/**/*"]
}
----

Esto asegura que TypeScript compile tanto el código fuente como los archivos de prueba.

=== Creación de un proyecto completo en TypeScript

Crear un proyecto completo en TypeScript implica configurar el entorno de desarrollo, escribir el código, compilarlo y ejecutar las pruebas. A continuación se describen los pasos para crear un proyecto completo en TypeScript.

==== 1. Inicializar el proyecto

Primero, inicializa un nuevo proyecto Node.js:

[source, bash]
----
npm init -y
----

==== 2. Instalar TypeScript

Instala TypeScript como una dependencia de desarrollo:

[source, bash]
----
npm install typescript --save-dev
----

==== 3. Configurar TypeScript

Crea un archivo `tsconfig.json` en la raíz del proyecto para configurar el compilador de TypeScript:

[source, json]
----
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true
    },
    "include": ["src/**/*"]
}
----

Este archivo configura TypeScript para compilar el código en ES6, usar el sistema de módulos CommonJS, y colocar los archivos compilados en el directorio `dist`.

==== 4. Escribir el código

Crea un directorio `src` y escribe tu código TypeScript. Por ejemplo, crea un archivo `src/index.ts`:

[source, typescript]
----
import * as http from "http";

const server = http.createServer((req, res) => {
    res.statusCode = 200;
    res.setHeader("Content-Type", "text/plain");
    res.end("Hello, TypeScript!\n");
});

server.listen(3000, () => {
    console.log("Server running at http://localhost:3000/");
});
----

==== 5. Compilar el código

Compila el código TypeScript ejecutando el comando `tsc`:

[source, bash]
----
npx tsc
----

Esto generará los archivos JavaScript compilados en el directorio `dist`.

==== 6. Ejecutar el código compilado

Ejecuta el código compilado con Node.js:

[source, bash]
----
node dist/index.js
----

==== 7. Configurar pruebas unitarias

Instala Jest y sus tipos como dependencias de desarrollo:

[source, bash]
----
npm install jest @types/jest ts-jest --save-dev
----

Crea un archivo de configuración para Jest llamado `jest.config.js`:

[source, javascript]
----
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts']
};
----

Escribe tus pruebas unitarias en el directorio `__tests__`. Por ejemplo, crea un archivo `__tests__/sum.test.ts`:

[source, typescript]
----
function sum(a: number, b: number): number {
    return a + b;
}

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
----

Ejecuta las pruebas utilizando Jest:

[source, bash]
----
npx jest
----

=== Despliegue y configuración para producción

Desplegar un proyecto TypeScript en producción implica compilar el código, configurar el entorno de producción y asegurarse de que la aplicación esté optimizada para el rendimiento. A continuación se describen los pasos para desplegar un proyecto TypeScript en producción.

==== 1. Compilar el código TypeScript

Primero, compila el código TypeScript para generar los archivos JavaScript que se ejecutarán en producción:

[source, bash]
----
npx tsc
----

Esto generará los archivos JavaScript compilados en el directorio especificado en `tsconfig.json` (por ejemplo, `dist`).

==== 2. Configurar el entorno de producción

Asegúrate de que tu aplicación esté configurada para el entorno de producción. Esto puede incluir la configuración de variables de entorno, la optimización del código y la configuración de herramientas de monitoreo.

[source, typescript]
----
if (process.env.NODE_ENV !== 'production') {
    require('dotenv').config();
}
----

==== 3. Optimizar el código

Utiliza herramientas como Webpack para optimizar el código JavaScript para producción. Webpack puede minificar el código, eliminar código muerto y realizar otras optimizaciones.

Instala Webpack y sus dependencias:

[source, bash]
----
npm install webpack webpack-cli ts-loader --save-dev
----

Crea un archivo de configuración para Webpack llamado `webpack.config.js`:

[source, javascript]
----
const path = require('path');

module.exports = {
    mode: 'production',
    entry: './src/index.ts',
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: 'ts-loader',
                exclude: /node_modules/,
            },
        ],
    },
    resolve: {
        extensions: ['.ts', '.js'],
    },
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist'),
    },
};
----

Ejecuta Webpack para generar el archivo optimizado:

[source, bash]
----
npx webpack
----

==== 4. Configurar el servidor para producción

Configura tu servidor para servir los archivos generados. Por ejemplo, si estás utilizando Node.js con Express, puedes configurar el servidor para servir el archivo `bundle.js`:

[source, typescript]
----
import * as express from 'express';
import * as path from 'path';

const app = express();
const port = process.env.PORT || 3000;

app.use(express.static(path.join(__dirname, 'dist')));

app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});

app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}/`);
});
----

==== 5. Desplegar la aplicación

Despliega la aplicación en un servicio de alojamiento como Heroku, AWS, o cualquier otro proveedor de tu elección. Asegúrate de seguir las mejores prácticas de despliegue para tu proveedor específico.

Por ejemplo, para desplegar en Heroku:

[source, bash]
----
heroku create
git push heroku main
----

== Módulo 10: Aspectos avanzados y mejores prácticas
=== Decoradores en TypeScript

Los decoradores en TypeScript son una característica experimental que permite modificar el comportamiento de clases, métodos, propiedades y parámetros. Los decoradores son funciones que se aplican a una declaración para modificarla de alguna manera.

==== 1. Habilitar los decoradores

Para usar decoradores en TypeScript, primero debes habilitarlos en el archivo `tsconfig.json`:

[source, json]
----
{
    "compilerOptions": {
        "target": "ES6",
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true
    }
}
----

==== 2. Decoradores de clase

Un decorador de clase se aplica a una clase y puede modificar su constructor o agregar propiedades y métodos adicionales.

[source, typescript]
----
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return `Hello, ${this.greeting}`;
    }
}
----

En este ejemplo, el decorador `@sealed` sella la clase `Greeter`, evitando que se agreguen nuevas propiedades o métodos.

==== 3. Decoradores de método

Un decorador de método se aplica a un método de una clase y puede modificar su comportamiento.

[source, typescript]
----
function enumerable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
    };
}

class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }

    @enumerable(false)
    greet() {
        return `Hello, ${this.greeting}`;
    }
}
----

En este ejemplo, el decorador `@enumerable(false)` establece que el método `greet` no es enumerable.

==== 4. Decoradores de propiedad

Un decorador de propiedad se aplica a una propiedad de una clase y puede modificar su comportamiento.

[source, typescript]
----
function format(formatString: string) {
    return function (target: any, propertyKey: string) {
        let value: string;

        const getter = function () {
            return value;
        };

        const setter = function (newVal: string) {
            value = `${formatString} ${newVal}`;
        };

        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true
        });
    };
}

class Greeter {
    @format("Hello")
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }
}
----

En este ejemplo, el decorador `@format("Hello")` modifica la propiedad `greeting` para que siempre tenga el prefijo "Hello".

==== 5. Decoradores de parámetro

Un decorador de parámetro se aplica a un parámetro de un método y puede modificar su comportamiento.

[source, typescript]
----
function logParameter(target: any, propertyKey: string, parameterIndex: number) {
    const metadataKey = `__log_${propertyKey}_parameters`;

    if (Array.isArray(target[metadataKey])) {
        target[metadataKey].push(parameterIndex);
    } else {
        target[metadataKey] = [parameterIndex];
    }
}

class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }

    greet(@logParameter name: string) {
        return `Hello, ${name}`;
    }
}
----

En este ejemplo, el decorador `@logParameter` registra el índice del parámetro decorado.

=== Manejo avanzado de tipos (`infer`, `typeof`, `keyof`, `in`)

TypeScript proporciona varias herramientas avanzadas para el manejo de tipos, que permiten crear tipos más complejos y flexibles. A continuación se describen algunos de estos conceptos avanzados: `infer`, `typeof`, `keyof` y `in`.

==== `infer`

La palabra clave `infer` se utiliza en los tipos condicionales para declarar un tipo dentro de la rama `true` de una condición. Es útil para extraer tipos dentro de los tipos condicionales.

[source, typescript]
----
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;

function exampleFunction(): string {
    return "Hello, TypeScript!";
}

type ExampleReturnType = ReturnType<typeof exampleFunction>; // string
----

En este ejemplo, `ReturnType` utiliza `infer` para extraer el tipo de retorno de una función.

==== `typeof`

La palabra clave `typeof` se utiliza para obtener el tipo de una variable o expresión en tiempo de compilación.

[source, typescript]
----
let exampleVariable = "Hello, TypeScript!";
type ExampleType = typeof exampleVariable; // string
----

En este ejemplo, `ExampleType` será del tipo `string`, que es el tipo de `exampleVariable`.

==== `keyof`

La palabra clave `keyof` se utiliza para obtener un tipo que representa todas las claves de un objeto.

[source, typescript]
----
interface Person {
    name: string;
    age: number;
}

type PersonKeys = keyof Person; // "name" | "age"
----

En este ejemplo, `PersonKeys` será un tipo que puede ser `"name"` o `"age"`.

==== `in`

La palabra clave `in` se utiliza en los tipos mapeados para iterar sobre las claves de un tipo.

[source, typescript]
----
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};

interface Person {
    name: string;
    age: number;
}

type ReadonlyPerson = Readonly<Person>;
----

En este ejemplo, `Readonly` es un tipo mapeado que convierte todas las propiedades de `T` en propiedades de solo lectura.

=== Operadores de tipo (`as`, `!`, `?`)

TypeScript proporciona varios operadores de tipo que permiten a los desarrolladores trabajar con tipos de manera más flexible y precisa. A continuación se describen los operadores `as`, `!` y `?`.

==== `as`

El operador `as` se utiliza para realizar una aserción de tipo, indicando al compilador que trate una expresión como un tipo específico.

[source, typescript]
----
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
----

En este ejemplo, `someValue` es de tipo `any`, pero se le dice al compilador que lo trate como un `string` usando `as string`, permitiendo acceder a la propiedad `length`.

==== `!`

El operador `!` se utiliza para indicar al compilador que una expresión no es `null` ni `undefined`. Esto es útil cuando el desarrollador sabe que una variable tiene un valor, pero el compilador no puede inferirlo.

[source, typescript]
----
let someValue: string | null = "this is a string";
let strLength: number = someValue!.length;
----

En este ejemplo, `someValue` puede ser `string` o `null`, pero el operador `!` indica al compilador que `someValue` no es `null` en este contexto.

==== `?`

El operador `?` se utiliza en dos contextos: para indicar propiedades opcionales en interfaces y tipos, y para la encadenación opcional.

[source, typescript]
----
// Propiedades opcionales
interface Person {
    name: string;
    age?: number;
}

let person: Person = { name: "John" };

// Encadenación opcional
let someValue: any = { name: "John" };
let nameLength: number | undefined = someValue?.name?.length;
----

En el primer ejemplo, la propiedad `age` es opcional en la interfaz `Person`, lo que significa que un objeto de tipo `Person` puede o no tener la propiedad `age`.

En el segundo ejemplo, la encadenación opcional `?.` se utiliza para acceder a propiedades de un objeto que pueden no existir, evitando errores si alguna propiedad en la cadena es `null` o `undefined`.

=== Creación de librerías y herramientas en TypeScript

Crear librerías y herramientas en TypeScript permite aprovechar las ventajas del tipado estático y las características avanzadas del lenguaje. A continuación se describen los pasos para crear una librería o herramienta en TypeScript.

==== 1. Inicializar el proyecto

Primero, inicializa un nuevo proyecto Node.js:

[source, bash]
----
npm init -y
----

==== 2. Instalar TypeScript

Instala TypeScript como una dependencia de desarrollo:

[source, bash]
----
npm install typescript --save-dev
----

==== 3. Configurar TypeScript

Crea un archivo `tsconfig.json` en la raíz del proyecto para configurar el compilador de TypeScript:

[source, json]
----
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "outDir": "./dist",
        "rootDir": "./src",
        "declaration": true,
        "strict": true,
        "esModuleInterop": true
    },
    "include": ["src/**/*"]
}
----

Este archivo configura TypeScript para compilar el código en ES6, usar el sistema de módulos CommonJS, generar archivos de declaración (`.d.ts`), y colocar los archivos compilados en el directorio `dist`.

==== 4. Escribir el código de la librería

Crea un directorio `src` y escribe el código de tu librería. Por ejemplo, crea un archivo `src/index.ts`:

[source, typescript]
----
export function add(a: number, b: number): number {
    return a + b;
}

export function subtract(a: number, b: number): number {
    return a - b;
}
----

==== 5. Compilar el código

Compila el código TypeScript ejecutando el comando `tsc`:

[source, bash]
----
npx tsc
----

Esto generará los archivos JavaScript compilados y los archivos de declaración de tipos en el directorio `dist`.

==== 6. Configurar el paquete para distribución

Asegúrate de que el archivo `package.json` esté configurado correctamente para la distribución de la librería. Por ejemplo:

[source, json]
----
{
    "name": "mi-libreria",
    "version": "1.0.0",
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
        "build": "tsc"
    },
    "devDependencies": {
        "typescript": "^4.0.0"
    }
}
----

Esto asegura que el archivo principal de la librería y los tipos estén correctamente referenciados.

==== 7. Publicar la librería

Publica la librería en npm para que otros desarrolladores puedan usarla:

[source, bash]
----
npm publish
----

==== 8. Usar la librería en un proyecto

Para usar la librería en un proyecto TypeScript, instálala desde npm:

[source, bash]
----
npm install mi-libreria
----

Luego, importa y usa las funciones de la librería en tu código:

[source, typescript]
----
import { add, subtract } from "mi-libreria";

console.log(add(2, 3)); // 5
console.log(subtract(5, 2)); // 3
----

=== Buenas prácticas y patrones comunes en TypeScript

Adoptar buenas prácticas y patrones comunes en TypeScript ayuda a mantener el código limpio, legible y fácil de mantener. A continuación se presentan algunas de las mejores prácticas y patrones comunes en TypeScript.

==== 1. Usar tipos explícitos

Siempre que sea posible, define tipos explícitos para variables, parámetros de funciones y valores de retorno. Esto mejora la legibilidad y ayuda a evitar errores.

[source, typescript]
----
function add(a: number, b: number): number {
    return a + b;
}
----

==== 2. Evitar el uso de `any`

El tipo `any` desactiva la verificación de tipos y debe evitarse siempre que sea posible. Usa tipos más específicos o `unknown` si no conoces el tipo exacto.

[source, typescript]
----
let value: unknown = "Hello, TypeScript!";
if (typeof value === "string") {
    console.log(value.toUpperCase());
}
----

==== 3. Usar interfaces y tipos

Utiliza interfaces y tipos para definir la forma de los objetos y las estructuras de datos. Esto mejora la claridad y facilita el mantenimiento del código.

[source, typescript]
----
interface Person {
    name: string;
    age: number;
}

const person: Person = {
    name: "John",
    age: 30
};
----

==== 4. Aprovechar las características de ES6+

TypeScript es compatible con muchas características de ES6 y versiones posteriores. Usa estas características para escribir código más limpio y conciso.

[source, typescript]
----
const numbers: number[] = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
----

==== 5. Usar `readonly` y `const`

Utiliza `readonly` para propiedades que no deben cambiar y `const` para variables que no deben reasignarse. Esto ayuda a prevenir errores y hace que el código sea más predecible.

[source, typescript]
----
class Person {
    readonly name: string;
    constructor(name: string) {
        this.name = name;
    }
}

const person = new Person("John");
// person.name = "Doe"; // Error: Cannot assign to 'name' because it is a read-only property.
----

==== 6. Manejar errores adecuadamente

Utiliza `try...catch` para manejar errores y proporciona mensajes de error claros. Considera la creación de errores personalizados para casos específicos.

[source, typescript]
----
class CustomError extends Error {
    constructor(message: string) {
        super(message);
        this.name = "CustomError";
    }
}

try {
    throw new CustomError("Something went wrong!");
} catch (error) {
    console.error(error.message);
}
----

==== 7. Escribir pruebas unitarias

Escribe pruebas unitarias para tu código utilizando herramientas como Jest. Las pruebas ayudan a asegurar que el código funcione correctamente y facilitan el mantenimiento.

[source, typescript]
----
function sum(a: number, b: number): number {
    return a + b;
}

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
----

==== 8. Documentar el código

Utiliza comentarios y JSDoc para documentar el código. La documentación ayuda a otros desarrolladores (y a ti mismo) a entender el propósito y el uso del código.

[source, typescript]
----
/**
 * Suma dos números.
 * @param a - El primer número.
 * @param b - El segundo número.
 * @returns La suma de los dos números.
 */
function add(a: number, b: number): number {
    return a + b;
}
----


