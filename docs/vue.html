<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>Curso de Vue 3</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article">
<div id="header">
<h1>Curso de Vue 3</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_módulo_1_introducción_a_vue_3">Módulo 1: Introducción a Vue 3</a>
<ul class="sectlevel2">
<li><a href="#_qué_es_vue_js">¿Qué es Vue.js?</a></li>
<li><a href="#_ventajas_y_casos_de_uso_de_vue_3">Ventajas y casos de uso de Vue 3</a></li>
<li><a href="#_instalación_y_configuración_de_vue_cli">Instalación y configuración de Vue CLI</a></li>
<li><a href="#_estructura_de_un_proyecto_vue">Estructura de un proyecto Vue</a></li>
<li><a href="#_creación_del_primer_proyecto_con_vue_3">Creación del primer proyecto con Vue 3</a></li>
<li><a href="#_comandos_adicionales_de_vue_cli">Comandos adicionales de Vue CLI</a></li>
</ul>
</li>
<li><a href="#_módulo_2_fundamentos_de_vue_3">Módulo 2: Fundamentos de Vue 3</a>
<ul class="sectlevel2">
<li><a href="#_declaración_de_datos_reactivamente_con_reactive_y_ref">Declaración de datos reactivamente con <code>reactive</code> y <code>ref</code></a>
<ul class="sectlevel3">
<li><a href="#_usando_ref_para_datos_primitivos_y_simples">Usando <code>ref</code> para datos primitivos y simples</a></li>
<li><a href="#_usando_reactive_para_objetos_y_arrays">Usando <code>reactive</code> para objetos y arrays</a></li>
<li><a href="#_ejemplo_combinado_de_ref_y_reactive">Ejemplo combinado de <code>ref</code> y <code>reactive</code></a></li>
</ul>
</li>
<li><a href="#_comprensión_de_data_computed_y_methods">Comprensión de <code>data</code>, <code>computed</code> y <code>methods</code></a>
<ul class="sectlevel3">
<li><a href="#_data_declaración_de_datos_reactivos"><code>data</code>: Declaración de datos reactivos</a></li>
<li><a href="#_computed_propiedades_calculadas"><code>computed</code>: Propiedades calculadas</a></li>
<li><a href="#_methods_definición_de_funciones_o_lógica_de_acción"><code>methods</code>: Definición de funciones o lógica de acción</a></li>
<li><a href="#_ejemplo_combinado_de_data_computed_y_methods">Ejemplo combinado de <code>data</code>, <code>computed</code> y <code>methods</code></a></li>
</ul>
</li>
<li><a href="#_trabajando_con_la_directiva_v_bind_y_v_model">Trabajando con la directiva <code>v-bind</code> y <code>v-model</code></a>
<ul class="sectlevel3">
<li><a href="#_v_bind_enlazando_atributos_y_propiedades_dinámicamente"><code>v-bind</code>: Enlazando atributos y propiedades dinámicamente</a></li>
<li><a href="#_v_model_enlazando_datos_bidireccionalmente"><code>v-model</code>: Enlazando datos bidireccionalmente</a></li>
<li><a href="#_uso_avanzado_de_v_model_enlace_en_componentes_personalizados">Uso avanzado de <code>v-model</code>: Enlace en componentes personalizados</a></li>
</ul>
</li>
<li><a href="#_eventos_en_vue_click_input_etc">Eventos en Vue: <code>@click</code>, <code>@input</code>, etc.</a>
<ul class="sectlevel3">
<li><a href="#_click_manejando_eventos_de_clic"><code>@click</code>: Manejando eventos de clic</a></li>
<li><a href="#_input_detectando_cambios_en_entradas_de_texto"><code>@input</code>: Detectando cambios en entradas de texto</a></li>
<li><a href="#_otros_eventos_comunes_change_submit_mouseover_etc">Otros eventos comunes (<code>@change</code>, <code>@submit</code>, <code>@mouseover</code>, etc.)</a></li>
</ul>
</li>
<li><a href="#_ciclo_de_vida_de_los_componentes_y_hooks_principales">Ciclo de vida de los componentes y hooks principales</a>
<ul class="sectlevel3">
<li><a href="#_ciclo_de_vida_de_un_componente_en_vue_3">Ciclo de vida de un componente en Vue 3</a></li>
<li><a href="#_uso_de_los_hooks_del_ciclo_de_vida_del_componente">Uso de los hooks del ciclo de vida del componente</a></li>
<li><a href="#_explicación_de_cada_hook">Explicación de cada hook</a></li>
<li><a href="#_ejemplo_de_un_componente_con_todos_los_hooks_del_ciclo_de_vida">Ejemplo de un componente con todos los hooks del ciclo de vida</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_3_componentes_en_vue_3">Módulo 3: Componentes en Vue 3</a>
<ul class="sectlevel2">
<li><a href="#_creación_y_uso_de_componentes_básicos">Creación y uso de componentes básicos</a>
<ul class="sectlevel3">
<li><a href="#_paso_1_crear_un_componente_básico">Paso 1: Crear un componente básico</a></li>
<li><a href="#_paso_2_importar_y_usar_el_componente_en_otro_componente_o_página">Paso 2: Importar y usar el componente en otro componente o página</a></li>
<li><a href="#_paso_3_pasar_props_a_un_componente">Paso 3: Pasar props a un componente</a></li>
<li><a href="#_paso_4_emitir_eventos_desde_un_componente">Paso 4: Emitir eventos desde un componente</a></li>
</ul>
</li>
<li><a href="#_comunicación_entre_componentes_con_props_y_emit">Comunicación entre componentes con <code>props</code> y <code>$emit</code></a>
<ul class="sectlevel3">
<li><a href="#_usando_props_para_pasar_datos_al_componente_hijo">Usando <code>props</code> para pasar datos al componente hijo</a></li>
<li><a href="#_emitiendo_eventos_desde_el_componente_hijo_con_emit">Emitiendo eventos desde el componente hijo con <code>$emit</code></a></li>
<li><a href="#_uso_de_v_model_personalizado_en_componentes_para_simplificar_props_y_emit">Uso de <code>v-model</code> personalizado en componentes para simplificar <code>props</code> y <code>$emit</code></a></li>
</ul>
</li>
<li><a href="#_scoped_slots_y_render_functions">Scoped Slots y Render Functions</a>
<ul class="sectlevel3">
<li><a href="#_uso_de_scoped_slots">Uso de Scoped Slots</a></li>
<li><a href="#_uso_de_render_functions">Uso de Render Functions</a></li>
</ul>
</li>
<li><a href="#_composición_de_componentes_y_reutilización_de_lógica">Composición de componentes y reutilización de lógica</a>
<ul class="sectlevel3">
<li><a href="#_creando_un_composable">Creando un Composable</a></li>
<li><a href="#_usando_un_composable_en_un_componente">Usando un Composable en un Componente</a></li>
<li><a href="#_composición_de_varios_componentes_en_vue_3">Composición de varios Componentes en Vue 3</a></li>
</ul>
</li>
<li><a href="#_comunicación_entre_componentes_padre_e_hijo">Comunicación entre Componentes Padre e Hijo</a></li>
<li><a href="#_uso_de_slots_para_mayor_flexibilidad">Uso de Slots para Mayor Flexibilidad</a>
<ul class="sectlevel3">
<li><a href="#_slots_básicos">Slots Básicos</a></li>
<li><a href="#_slots_nombrados">Slots Nombrados</a></li>
<li><a href="#_slots_dinámicos">Slots Dinámicos</a></li>
</ul>
</li>
<li><a href="#_composición_de_componentes_con_provideinject">Composición de Componentes con Provide/Inject</a>
<ul class="sectlevel3">
<li><a href="#_beneficios_de_la_composición_y_la_reutilización_de_lógica">Beneficios de la Composición y la Reutilización de Lógica</a></li>
</ul>
</li>
<li><a href="#_introducción_a_la_api_de_composición_setup_reactive_y_ref">Introducción a la API de Composición: <code>setup()</code>, <code>reactive()</code>, y <code>ref()</code></a>
<ul class="sectlevel3">
<li><a href="#_el_método_setup">El método <code>setup()</code></a></li>
<li><a href="#_ref_variables_reactivas_con_referencias"><code>ref()</code>: Variables reactivas con referencias</a></li>
<li><a href="#_reactive_objetos_reactivos_completos"><code>reactive()</code>: Objetos reactivos completos</a></li>
<li><a href="#_comparación_entre_ref_y_reactive">Comparación entre <code>ref()</code> y <code>reactive()</code></a></li>
<li><a href="#_ejemplo_práctico_combinando_ref_y_reactive">Ejemplo práctico: Combinando <code>ref()</code> y <code>reactive()</code></a></li>
<li><a href="#_resumen">Resumen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_4_manejo_de_estados_con_pinia">Módulo 4: Manejo de Estados con Pinia</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_pinia_como_alternativa_a_vuex">Introducción a Pinia como alternativa a Vuex</a>
<ul class="sectlevel3">
<li><a href="#_ventajas_de_pinia_sobre_vuex">Ventajas de Pinia sobre Vuex</a></li>
<li><a href="#_instalación_de_pinia">Instalación de Pinia</a></li>
<li><a href="#_creación_de_una_store_básica_en_pinia">Creación de una store básica en Pinia</a></li>
<li><a href="#_usando_una_store_en_un_componente">Usando una store en un componente</a></li>
<li><a href="#_estado_derivado_y_getters_en_pinia">Estado Derivado y Getters en Pinia</a></li>
</ul>
</li>
<li><a href="#_definiendo_un_store_con_getters">Definiendo un Store con Getters</a></li>
<li><a href="#_usando_getters_en_componentes">Usando Getters en Componentes</a></li>
<li><a href="#_getters_con_parámetros">Getters con Parámetros</a></li>
<li><a href="#_usando_getters_con_parámetros_en_componentes">Usando Getters con Parámetros en Componentes</a></li>
<li><a href="#_computed_properties_vs_getters">Computed Properties vs Getters</a></li>
<li><a href="#_organización_del_estado_global_con_pinia">Organización del estado global con Pinia</a>
<ul class="sectlevel3">
<li><a href="#_creación_de_múltiples_stores">Creación de múltiples stores</a></li>
<li><a href="#_accediendo_al_estado_global_desde_componentes">Accediendo al estado global desde componentes</a></li>
<li><a href="#_estructura_de_carpetas_para_múltiples_stores">Estructura de Carpetas para Múltiples stores</a></li>
<li><a href="#_composición_de_stores">Composición de stores</a></li>
<li><a href="#_resumen_2">Resumen</a></li>
</ul>
</li>
<li><a href="#_creación_de_stores_y_acceso_desde_componentes">Creación de stores y acceso desde componentes</a>
<ul class="sectlevel3">
<li><a href="#_creación_de_un_store_básico">Creación de un store básico</a></li>
<li><a href="#_accediendo_a_un_store_desde_un_componente">Accediendo a un store desde un componente</a></li>
<li><a href="#_utilizando_múltiples_stores_en_un_componente">Utilizando múltiples stores en un componente</a></li>
<li><a href="#_ejemplo_avanzado_getters_y_acciones_asíncronas">Ejemplo avanzado: Getters y acciones asíncronas</a></li>
<li><a href="#_resumen_3">Resumen</a></li>
</ul>
</li>
<li><a href="#_mejores_prácticas_de_uso_de_pinia_en_aplicaciones_vue_3">Mejores prácticas de uso de Pinia en aplicaciones Vue 3</a></li>
</ul>
</li>
<li><a href="#_módulo_5_rutado_con_vue_router_4">Módulo 5: Rutado con Vue Router 4</a>
<ul class="sectlevel2">
<li><a href="#_configuración_de_vue_router_4_en_vue_3">Configuración de Vue Router 4 en Vue 3</a>
<ul class="sectlevel3">
<li><a href="#_instalación_de_vue_router">Instalación de Vue Router</a></li>
<li><a href="#_configuración_básica_de_vue_router">Configuración básica de Vue Router</a></li>
<li><a href="#_integración_de_vue_router_con_la_aplicación_vue">Integración de Vue Router con la aplicación Vue</a></li>
<li><a href="#_navegación_entre_vistas">Navegación entre vistas</a></li>
<li><a href="#_rutas_dinámicas_con_parámetros">Rutas dinámicas con parámetros</a></li>
<li><a href="#_rutas_anidadas">Rutas anidadas</a></li>
<li><a href="#_navegación_programática">Navegación programática</a></li>
<li><a href="#_manejo_de_rutas_no_encontradas_404">Manejo de rutas no encontradas (404)</a></li>
<li><a href="#_resumen_4">Resumen</a></li>
</ul>
</li>
<li><a href="#_protegiendo_rutas_con_guardias_de_navegación">Protegiendo rutas con guardias de navegación</a>
<ul class="sectlevel3">
<li><a href="#_guardias_de_navegación_globales">Guardias de navegación globales</a></li>
<li><a href="#_guardias_específicos_de_ruta">Guardias específicos de ruta</a></li>
<li><a href="#_guardias_de_navegación_dentro_de_componentes">Guardias de navegación dentro de componentes</a></li>
<li><a href="#_uso_de_meta_campos_para_roles_y_permisos">Uso de meta campos para roles y permisos</a></li>
<li><a href="#_resumen_5">Resumen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_6_api_de_composición_avanzada">Módulo 6: API de Composición Avanzada</a>
<ul class="sectlevel2">
<li><a href="#_uso_avanzado_de_reactive_torefs_y_toref">Uso avanzado de <code>reactive</code>, <code>toRefs</code> y <code>toRef</code></a>
<ul class="sectlevel3">
<li><a href="#_reactive"><code>reactive</code></a></li>
<li><a href="#_torefs"><code>toRefs</code></a></li>
<li><a href="#_toref"><code>toRef</code></a></li>
<li><a href="#_combinación_de_reactive_torefs_y_toref">Combinación de <code>reactive</code>, <code>toRefs</code> y <code>toRef</code></a></li>
<li><a href="#_consideraciones_al_usar_torefs_y_toref">Consideraciones al usar <code>toRefs</code> y <code>toRef</code></a></li>
<li><a href="#_resumen_6">Resumen</a></li>
</ul>
</li>
<li><a href="#_provide_y_inject_para_dependencias"><code>provide</code> y <code>inject</code> para dependencias</a>
<ul class="sectlevel3">
<li><a href="#_uso_de_provide_para_compartir_datos_desde_un_componente_padre">Uso de <code>provide</code> para compartir datos desde un componente padre</a></li>
<li><a href="#_uso_de_inject_para_consumir_datos_en_un_componente_hijo">Uso de <code>inject</code> para consumir datos en un componente hijo</a></li>
<li><a href="#_proveer_funciones_como_dependencias">Proveer funciones como dependencias</a></li>
<li><a href="#_valores_predeterminados_con_inject">Valores predeterminados con <code>inject</code></a></li>
<li><a href="#_provide_e_inject_reactivos_con_ref_o_reactive"><code>provide</code> e <code>inject</code> reactivos con <code>ref</code> o <code>reactive</code></a></li>
<li><a href="#_resumen_7">Resumen</a></li>
</ul>
</li>
<li><a href="#_uso_de_watch_y_watcheffect_para_observación_reactiva">Uso de <code>watch</code> y <code>watchEffect</code> para observación reactiva</a>
<ul class="sectlevel3">
<li><a href="#_watch_observando_propiedades_específicas"><code>watch</code>: Observando propiedades específicas</a></li>
<li><a href="#_observación_de_propiedades_dentro_de_objetos_reactivos">Observación de propiedades dentro de objetos reactivos</a></li>
<li><a href="#_watcheffect_observación_automática_de_dependencias"><code>watchEffect</code>: Observación automática de dependencias</a></li>
<li><a href="#_diferencias_clave_entre_watch_y_watcheffect">Diferencias clave entre <code>watch</code> y <code>watchEffect</code></a></li>
<li><a href="#_ejemplo_combinado_de_watch_y_watcheffect">Ejemplo combinado de <code>watch</code> y <code>watchEffect</code></a></li>
<li><a href="#_resumen_8">Resumen</a></li>
</ul>
</li>
<li><a href="#_creación_de_composables_personalizados">Creación de composables personalizados</a></li>
<li><a href="#_optimización_y_reutilización_de_lógica_con_composables">Optimización y reutilización de lógica con composables</a>
<ul class="sectlevel3">
<li><a href="#_creación_de_un_composable_básico">Creación de un composable básico</a></li>
<li><a href="#_usando_un_composable_en_un_componente_2">Usando un composable en un componente</a></li>
<li><a href="#_composables_con_datos_reactivos_y_watch">Composables con datos reactivos y <code>watch</code></a></li>
<li><a href="#_reutilización_avanzada_con_parámetros_en_composables">Reutilización avanzada con parámetros en composables</a></li>
<li><a href="#_composables_con_provide_e_inject_para_dependencia_global">Composables con <code>provide</code> e <code>inject</code> para dependencia global</a></li>
<li><a href="#_resumen_9">Resumen</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_7_integración_de_servicios_y_apis">Módulo 7: Integración de Servicios y APIs</a>
<ul class="sectlevel2">
<li><a href="#_comunicación_con_apis_rest_usando_axios_y_fetch">Comunicación con APIs REST usando <code>axios</code> y <code>fetch</code></a>
<ul class="sectlevel3">
<li><a href="#_instalación_de_axios">Instalación de <code>axios</code></a></li>
<li><a href="#_realizando_solicitudes_con_axios">Realizando solicitudes con <code>axios</code></a></li>
<li><a href="#_realizando_solicitudes_post_con_axios">Realizando solicitudes POST con <code>axios</code></a></li>
<li><a href="#_uso_de_la_api_fetch">Uso de la API <code>fetch</code></a></li>
<li><a href="#_realizando_solicitudes_post_con_fetch">Realizando solicitudes POST con <code>fetch</code></a></li>
<li><a href="#_resumen_10">Resumen</a></li>
</ul>
</li>
<li><a href="#_manejo_de_promesas_y_datos_asíncronos_en_componentes">Manejo de promesas y datos asíncronos en componentes</a>
<ul class="sectlevel3">
<li><a href="#_promesas_y_la_api_fetch">Promesas y la API <code>fetch</code></a></li>
<li><a href="#_uso_de_axios_para_manejar_promesas">Uso de <code>axios</code> para manejar promesas</a></li>
<li><a href="#_manejo_de_múltiples_promesas">Manejo de múltiples promesas</a></li>
<li><a href="#_actualización_de_datos_reactivos_en_tiempo_real">Actualización de datos reactivos en tiempo real</a></li>
<li><a href="#_resumen_11">Resumen</a></li>
</ul>
</li>
<li><a href="#_carga_y_visualización_de_datos_externos">Carga y visualización de datos externos</a>
<ul class="sectlevel3">
<li><a href="#_carga_de_datos_externos_con_fetch">Carga de datos externos con <code>fetch</code></a></li>
<li><a href="#_carga_de_datos_externos_con_axios">Carga de datos externos con <code>axios</code></a></li>
<li><a href="#_visualización_de_datos_en_componentes">Visualización de datos en componentes</a></li>
<li><a href="#_manejo_de_estados_de_carga">Manejo de estados de carga</a></li>
<li><a href="#_resumen_12">Resumen</a></li>
</ul>
</li>
<li><a href="#_tratamiento_de_errores_y_validaciones_de_api">Tratamiento de errores y validaciones de API</a></li>
<li><a href="#_introducción_a_websockets_en_vue_3">Introducción a WebSockets en Vue 3</a></li>
</ul>
</li>
<li><a href="#_módulo_8_pruebas_en_vue_3">Módulo 8: Pruebas en Vue 3</a>
<ul class="sectlevel2">
<li><a href="#_pruebas_unitarias_con_vuetest_utils_y_vitest">Pruebas unitarias con <code>@vue/test-utils</code> y Vitest</a>
<ul class="sectlevel3">
<li><a href="#_configuración_del_entorno_de_pruebas">Configuración del entorno de pruebas</a></li>
<li><a href="#_escribiendo_pruebas_unitarias">Escribiendo pruebas unitarias</a></li>
<li><a href="#_ejecutando_pruebas">Ejecutando pruebas</a></li>
<li><a href="#_pruebas_de_componentes_con_propiedades_props">Pruebas de componentes con propiedades (<code>props</code>)</a></li>
<li><a href="#_pruebas_de_métodos_y_estados_reactivos">Pruebas de métodos y estados reactivos</a></li>
<li><a href="#_resumen_13">Resumen</a></li>
</ul>
</li>
<li><a href="#_simulación_de_eventos_y_cambios_de_estado">Simulación de eventos y cambios de estado</a></li>
<li><a href="#_ejecutar_pruebas">Ejecutar pruebas</a></li>
<li><a href="#_pruebas_de_pinia_y_vue_router_en_componentes_con_vitest">Pruebas de Pinia y Vue Router en componentes con Vitest</a></li>
<li><a href="#_pruebas_de_pinia">Pruebas de Pinia</a></li>
<li><a href="#_pruebas_de_vue_router">Pruebas de Vue Router</a></li>
<li><a href="#_combinando_pinia_y_vue_router">Combinando Pinia y Vue Router</a></li>
<li><a href="#_ejecutar_pruebas_2">Ejecutar pruebas</a></li>
<li><a href="#_buenas_prácticas_para_pruebas_unitarias">Buenas prácticas para pruebas unitarias</a></li>
<li><a href="#_pruebas_de_integración_para_asegurar_la_funcionalidad_completa">Pruebas de integración para asegurar la funcionalidad completa</a></li>
</ul>
</li>
<li><a href="#_módulo_9_optimización_de_rendimiento">Módulo 9: Optimización de Rendimiento</a>
<ul class="sectlevel2">
<li><a href="#_code_splitting_y_lazy_loaging">Code splitting y lazy loaging</a></li>
<li><a href="#_uso_de_keep_alive_para_optimizar_el_cacheo_de_componentes">Uso de <code>keep-alive</code> para optimizar el cacheo de componentes</a></li>
<li><a href="#_lazy_loading_en_rutas_y_componentes">Lazy loading en rutas y componentes</a></li>
<li><a href="#_herramientas_para_la_optimización_de_performance_en_vue">Herramientas para la optimización de performance en Vue</a></li>
<li><a href="#_buenas_prácticas_para_aplicaciones_vue_eficientes">Buenas prácticas para aplicaciones Vue eficientes</a></li>
</ul>
</li>
<li><a href="#_módulo_10_despliegue_y_construcción_para_producción">Módulo 10: Despliegue y Construcción para Producción</a>
<ul class="sectlevel2">
<li><a href="#_preparación_de_la_aplicación_para_producción">Preparación de la aplicación para producción</a></li>
<li><a href="#_construcción_y_minificación_del_proyecto_vue">Construcción y minificación del proyecto Vue</a></li>
<li><a href="#_configuración_para_servidores_estáticos_netlify_vercel_github_pages">Configuración para servidores estáticos (Netlify, Vercel, GitHub Pages)</a></li>
<li><a href="#_despliegue_de_aplicaciones_en_entornos_de_producción">Despliegue de aplicaciones en entornos de producción</a></li>
<li><a href="#_monitorización_y_mantenimiento_post_despliegue">Monitorización y mantenimiento post-despliegue</a></li>
</ul>
</li>
<li><a href="#_módulo_11_librerías_y_recursos_adicionales">Módulo 11: Librerías y Recursos Adicionales</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_módulo_1_introducción_a_vue_3">Módulo 1: Introducción a Vue 3</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_qué_es_vue_js">¿Qué es Vue.js?</h3>
<div class="paragraph">
<p>Vue.js es un framework progresivo para construir interfaces de usuario. Se centra en la capa de vista de la aplicación y permite la creación de aplicaciones web interactivas y dinámicas. Vue es fácil de integrar con otras bibliotecas y proyectos existentes, lo que lo hace ideal para proyectos de cualquier tamaño.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ventajas_y_casos_de_uso_de_vue_3">Ventajas y casos de uso de Vue 3</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Reactividad:</strong> Vue utiliza un sistema de reactividad que permite que los cambios en los datos se reflejen automáticamente en la interfaz de usuario.</p>
</li>
<li>
<p><strong>Composición:</strong> La nueva API de Composición permite organizar y reutilizar la lógica de manera más efectiva.</p>
</li>
<li>
<p><strong>Tamaño:</strong> Vue es ligero y rápido, lo que mejora el rendimiento en comparación con otros frameworks.</p>
</li>
<li>
<p><strong>Ecosistema:</strong> Una amplia gama de herramientas y bibliotecas, como Vue Router y Pinia, facilitan el desarrollo de aplicaciones complejas.</p>
</li>
<li>
<p><strong>Casos de uso:</strong> Ideal para aplicaciones de una sola página (SPA), así como para integrarse en proyectos existentes o para desarrollar nuevas aplicaciones desde cero.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_instalación_y_configuración_de_vue_cli">Instalación y configuración de Vue CLI</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Crear un nuevo proyecto:</strong> Usar el siguiente comando para crear un nuevo proyecto:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Usando Vue CLI</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npm create vue@latest</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Configuración inicial:</strong> Durante la creación, se puede seleccionar la configuración predeterminada o personalizada (como TypeScript, Router, Pinia).</p>
</li>
<li>
<p><strong>Estructura de carpetas:</strong> Comprender la estructura generada por Vue CLI, incluyendo <code>src</code>, <code>public</code>, y <code>node_modules</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-tree hljs" data-lang="tree">mi-proyecto
├── public
│   ├── favicon.ico
├── src
    ├── assets
    |   ├── logo.svg
    |   ├── base.css
    |   ├── main.css
    ├── components
    |   ├── __tests__
    |   |   ├── HelloWorld.spec.ts
    |   ├── icons
    |       ├── IconCommunity.vue
    |       ├── IconDocumentation.vue
    |       ├── IconEcosystem.vue
    |       ├── IconSupport.vue
    |       ├── HelloWorld.vue
    ├── App.vue
    ├── router
    ├── stores
    ├── views</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estructura_de_un_proyecto_vue">Estructura de un proyecto Vue</h3>
<div class="ulist">
<ul>
<li>
<p><strong>src:</strong> Contiene el código fuente de la aplicación.</p>
</li>
<li>
<p><strong>main.ts:</strong> Punto de entrada de la aplicación.</p>
</li>
<li>
<p><strong>App.vue:</strong> Componente raíz de la aplicación.</p>
</li>
<li>
<p><strong>components:</strong> Carpeta para componentes reutilizables.</p>
</li>
<li>
<p><strong>views:</strong> Carpeta para componentes que representan páginas completas.</p>
</li>
<li>
<p><strong>router:</strong> Configuración de rutas para la navegación.</p>
</li>
<li>
<p><strong>store:</strong> Estado global gestionado con Pinia.</p>
</li>
<li>
<p><strong>assets:</strong> Recursos estáticos como imágenes y archivos CSS.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creación_del_primer_proyecto_con_vue_3">Creación del primer proyecto con Vue 3</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Ejecutar el proyecto:</strong> Una vez creado, navegar a la carpeta del proyecto y ejecutar el servidor de desarrollo:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  cd mi-proyecto
  npm run serve</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Exploración de la aplicación inicial:</strong> Acceder a <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code> y explorar la aplicación predeterminada generada.</p>
</li>
<li>
<p><strong>Modificación de la aplicación:</strong> Realizar cambios en <code>App.vue</code> para ver cómo se actualiza la interfaz en tiempo real.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_comandos_adicionales_de_vue_cli">Comandos adicionales de Vue CLI</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Compilación para producción:</strong> Generar una versión optimizada para producción.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npm run build</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pruebas unitarias:</strong> Ejecutar pruebas unitarias con Vitest.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npm run test:unit</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pruebas E2E:</strong> Ejecutar pruebas end-to-end con Cypress.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npm run test:e2e</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_2_fundamentos_de_vue_3">Módulo 2: Fundamentos de Vue 3</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_declaración_de_datos_reactivamente_con_reactive_y_ref">Declaración de datos reactivamente con <code>reactive</code> y <code>ref</code></h3>
<div class="paragraph">
<p>Vue 3 proporciona dos formas principales de declarar datos reactivos en la Composition API: <code>reactive</code> y <code>ref</code>. Ambos métodos permiten gestionar el estado de los datos de manera reactiva, pero tienen diferencias en su uso y en el tipo de datos que manejan.</p>
</div>
<div class="sect3">
<h4 id="_usando_ref_para_datos_primitivos_y_simples">Usando <code>ref</code> para datos primitivos y simples</h4>
<div class="paragraph">
<p><code>ref</code> se utiliza para crear una referencia reactiva a valores primitivos o datos que no requieren estructuras complejas. Al utilizar <code>ref</code>, Vue envuelve el valor en un objeto reactivo que se actualiza automáticamente cuando cambia.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { ref } from 'vue';

const count = ref(0);
const message = ref('Hola Mundo');

// Para acceder al valor, se utiliza .value
console.log(count.value);  // Imprime: 0
console.log(message.value); // Imprime: Hola Mundo

// Modificar el valor automáticamente notifica a Vue
count.value += 1;
message.value = 'Nuevo mensaje';</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usando_reactive_para_objetos_y_arrays">Usando <code>reactive</code> para objetos y arrays</h4>
<div class="paragraph">
<p><code>reactive</code> es ideal para manejar objetos y arrays, ya que convierte todos los campos del objeto en datos reactivos. Esto permite actualizar directamente las propiedades del objeto o los elementos del array sin tener que acceder a través de <code>.value</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { reactive } from 'vue';

const user = reactive({
  name: 'Juan',
  age: 25,
});

const tasks = reactive([
  { id: 1, text: 'Aprender Vue', done: false },
  { id: 2, text: 'Construir una app', done: true },
]);

// Modificar propiedades actualiza el objeto completo reactivamente
user.name = 'Carlos';
tasks.push({ id: 3, text: 'Dominar Composition API', done: false });</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_combinado_de_ref_y_reactive">Ejemplo combinado de <code>ref</code> y <code>reactive</code></h4>
<div class="paragraph">
<p>Se pueden combinar <code>ref</code> y <code>reactive</code> según las necesidades de los datos. A continuación, un ejemplo de un componente que utiliza ambos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
    &lt;p&gt;Usuario: {{ user.name }} - Edad: {{ user.age }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref, reactive } from 'vue';

const count = ref(0);
const user = reactive({ name: 'Ana', age: 30 });

const increment = () =&gt; {
  count.value++;
  user.age++;
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente, <code>count</code> se maneja con <code>ref</code> por ser un valor simple, mientras que <code>user</code> se declara con <code>reactive</code> para actualizar automáticamente cada una de sus propiedades.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comprensión_de_data_computed_y_methods">Comprensión de <code>data</code>, <code>computed</code> y <code>methods</code></h3>
<div class="paragraph">
<p>En Vue 3, los datos y las funciones que forman el estado y la lógica de un componente se gestionan principalmente con <code>data</code>, <code>computed</code> y <code>methods</code>. Estas propiedades son clave para estructurar la lógica y el estado reactivo en los componentes.</p>
</div>
<div class="sect3">
<h4 id="_data_declaración_de_datos_reactivos"><code>data</code>: Declaración de datos reactivos</h4>
<div class="paragraph">
<p><code>data</code> en la Composition API se representa mediante <code>ref</code> y <code>reactive</code>, los cuales permiten definir datos que pueden ser observados y actualizados reactivamente. Estos valores se declaran dentro de la función <code>setup</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { ref, reactive } from 'vue';

const count = ref(0);  // dato reactivo primitivo
const user = reactive({ name: 'Ana', age: 25 });  // objeto reactivo</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_computed_propiedades_calculadas"><code>computed</code>: Propiedades calculadas</h4>
<div class="paragraph">
<p>Las propiedades <code>computed</code> se utilizan para declarar valores que dependen de otros datos y que necesitan ser recalculados automáticamente cuando los datos base cambian. Una propiedad <code>computed</code> es una función que devuelve un valor basado en otros valores reactivos. Esto permite encapsular lógica derivada sin repetir el cálculo en múltiples lugares del componente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { ref, computed } from 'vue';

const price = ref(100);
const quantity = ref(2);

// La propiedad total se recalcula automáticamente si price o quantity cambian
const total = computed(() =&gt; price.value * quantity.value);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_methods_definición_de_funciones_o_lógica_de_acción"><code>methods</code>: Definición de funciones o lógica de acción</h4>
<div class="paragraph">
<p><code>methods</code> en la Composition API se representa como funciones que definen la lógica del componente. Estas funciones se declaran dentro de <code>setup</code> y pueden ser llamadas desde el template o por otros métodos. A diferencia de las propiedades <code>computed</code>, los métodos se ejecutan en respuesta a eventos específicos, como clics de botones o eventos personalizados.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { ref } from 'vue';

const count = ref(0);

const increment = () =&gt; {
  count.value++;
};

const decrement = () =&gt; {
  if (count.value &gt; 0) {
    count.value--;
  }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_combinado_de_data_computed_y_methods">Ejemplo combinado de <code>data</code>, <code>computed</code> y <code>methods</code></h4>
<div class="paragraph">
<p>A continuación, un ejemplo completo que utiliza <code>data</code> para manejar el estado, <code>computed</code> para definir una propiedad calculada y <code>methods</code> para crear acciones.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Precio unitario: {{ price }}&lt;/p&gt;
    &lt;p&gt;Cantidad: {{ quantity }}&lt;/p&gt;
    &lt;p&gt;Total: {{ total }}&lt;/p&gt;
    &lt;button @click="incrementQuantity"&gt;Incrementar cantidad&lt;/button&gt;
    &lt;button @click="decrementQuantity"&gt;Reducir cantidad&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref, computed } from 'vue';

  const price = ref(50);
  const quantity = ref(1);

  const total = computed(() =&gt; price.value * quantity.value);

  const incrementQuantity = () =&gt; {
    quantity.value++;
  };

  const decrementQuantity = () =&gt; {
    if (quantity.value &gt; 1) {
      quantity.value--;
    }
  };
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="olist arabic">
<div class="title">En este componente:</div>
<ol class="arabic">
<li>
<p><code>price</code> y <code>quantity</code> se manejan como datos reactivos con <code>ref</code>.</p>
</li>
<li>
<p><code>total</code> se define como una propiedad <code>computed</code> que se actualiza automáticamente cuando <code>price</code> o <code>quantity</code> cambian.</p>
</li>
<li>
<p><code>incrementQuantity</code> y <code>decrementQuantity</code> son métodos que permiten modificar el valor de <code>quantity</code> en respuesta a eventos de clic.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trabajando_con_la_directiva_v_bind_y_v_model">Trabajando con la directiva <code>v-bind</code> y <code>v-model</code></h3>
<div class="paragraph">
<p>Vue 3 ofrece diversas directivas que facilitan el enlace de datos entre el componente y su plantilla. Entre las más utilizadas están <code>v-bind</code> y <code>v-model</code>. Estas permiten sincronizar datos reactivos en diferentes situaciones, como el enlace de atributos HTML (<code>v-bind</code>) o el enlace bidireccional en elementos de formulario (<code>v-model</code>).</p>
</div>
<div class="sect3">
<h4 id="_v_bind_enlazando_atributos_y_propiedades_dinámicamente"><code>v-bind</code>: Enlazando atributos y propiedades dinámicamente</h4>
<div class="paragraph">
<p>La directiva <code>v-bind</code> permite enlazar valores de JavaScript a atributos HTML y propiedades de componentes. Esto es útil para cambiar dinámicamente atributos como <code>class</code>, <code>style</code>, o <code>src</code>, o para pasar datos a componentes hijos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;img :src="imageUrl" alt="Imagen dinámica" /&gt;
    &lt;button :class="{ active: isActive }" @click="toggleActive"&gt;Toggle Estado&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref } from 'vue';

  const imageUrl = ref('https://via.placeholder.com/150');
  const isActive = ref(false);

  const toggleActive = () =&gt; {
    isActive.value = !isActive.value;
  };
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>:src="imageUrl"</code> enlaza dinámicamente la URL de una imagen al valor de <code>imageUrl</code>.</p>
</li>
<li>
<p><code>:class="{ active: isActive }"</code> aplica la clase <code>active</code> solo cuando <code>isActive</code> es <code>true</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_v_model_enlazando_datos_bidireccionalmente"><code>v-model</code>: Enlazando datos bidireccionalmente</h4>
<div class="paragraph">
<p><code>v-model</code> es una directiva que crea un enlace bidireccional entre el valor de un elemento de formulario y una variable en el componente. Esto permite que, al cambiar el valor en el formulario, el dato en el componente se actualice automáticamente y viceversa. En Vue 3, <code>v-model</code> también admite personalización mediante el uso de modificadores y nombres de propiedad.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;label for="username"&gt;Nombre de usuario:&lt;/label&gt;
    &lt;input id="username" v-model="username" placeholder="Ingresa tu nombre" /&gt;
    &lt;p&gt;Hola, {{ username }}!&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref } from 'vue';
  const username = ref('');
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, <code>v-model</code> enlaza el campo de entrada <code>input</code> con la variable <code>username</code>. Cuando el usuario escribe en el campo, <code>username</code> se actualiza automáticamente, y el mensaje de bienvenida se muestra con el nombre ingresado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_uso_avanzado_de_v_model_enlace_en_componentes_personalizados">Uso avanzado de <code>v-model</code>: Enlace en componentes personalizados</h4>
<div class="paragraph">
<p>En Vue 3, <code>v-model</code> se puede utilizar en componentes personalizados para enlazar propiedades de forma bidireccional, proporcionando una experiencia de edición fluida.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;CustomInput v-model="userInput" /&gt;
    &lt;p&gt;Valor ingresado: {{ userInput }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref } from 'vue';
  import CustomInput from './CustomInput.vue';
  const userInput = ref('');
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el componente <code>CustomInput</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;input :value="modelValue" @input="$emit('update:modelValue', $event.target.value)" /&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { defineProps, defineEmits } from 'vue';

const props = defineProps&lt;{ modelValue: string }&gt;();
const emit = defineEmits&lt;{
  (e: 'update:modelValue', value: string): void;
}&gt;();
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Aquí:</div>
<ul>
<li>
<p><code>CustomInput</code> recibe <code>modelValue</code> como una propiedad, que es el nombre por defecto que usa <code>v-model</code> en Vue 3.</p>
</li>
<li>
<p>Cuando el usuario escribe en el <code>input</code>, <code>CustomInput</code> emite un evento <code>update:modelValue</code> para actualizar <code>userInput</code> en el componente padre.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este enfoque permite que <code>v-model</code> maneje datos en componentes personalizados de forma similar a como lo hace con elementos nativos de formulario.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_eventos_en_vue_click_input_etc">Eventos en Vue: <code>@click</code>, <code>@input</code>, etc.</h3>
<div class="paragraph">
<p>Vue permite gestionar eventos en el DOM de manera sencilla mediante directivas como <code>@click</code> o <code>@input</code>. Estas directivas escuchan eventos del navegador y ejecutan funciones o expresiones en respuesta. Esta sección cubre los eventos comunes y su uso en la Composition API.</p>
</div>
<div class="sect3">
<h4 id="_click_manejando_eventos_de_clic"><code>@click</code>: Manejando eventos de clic</h4>
<div class="paragraph">
<p>El evento <code>@click</code> se utiliza para escuchar clics en elementos HTML. Es útil para activar acciones cuando el usuario interactúa con botones, enlaces o cualquier elemento clicable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;button @click="handleClick"&gt;Haz clic aquí&lt;/button&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';

const clickCount = ref(0);

const handleClick = () =&gt; {
  clickCount.value++;
  console.log(`Botón clicado ${clickCount.value} veces`);
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>@click="handleClick"</code> escucha los clics en el botón y llama a la función <code>handleClick</code> cada vez que se produce el evento.</p>
</li>
<li>
<p><code>clickCount</code> cuenta los clics acumulados y se actualiza reactivamente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_input_detectando_cambios_en_entradas_de_texto"><code>@input</code>: Detectando cambios en entradas de texto</h4>
<div class="paragraph">
<p>El evento <code>@input</code> detecta cambios en los elementos de formulario, como entradas de texto o áreas de texto, actualizando el estado del componente conforme el usuario escribe.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;input @input="handleInput" placeholder="Escribe algo..." /&gt;
  &lt;p&gt;Valor ingresado: {{ inputValue }}&lt;/p&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';

const inputValue = ref('');

const handleInput = (event: Event) =&gt; {
  const target = event.target as HTMLInputElement;
  inputValue.value = target.value;
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este caso:</div>
<ul>
<li>
<p><code>@input="handleInput"</code> llama a <code>handleInput</code> cada vez que cambia el valor del campo de texto.</p>
</li>
<li>
<p><code>inputValue</code> refleja el texto ingresado, que se muestra en el párrafo a medida que el usuario escribe.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_otros_eventos_comunes_change_submit_mouseover_etc">Otros eventos comunes (<code>@change</code>, <code>@submit</code>, <code>@mouseover</code>, etc.)</h4>
<div class="paragraph">
<p>Vue permite manejar otros eventos comunes en el DOM, utilizando la misma sintaxis de <code>@&lt;evento&gt;</code>. Algunos ejemplos incluyen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><code>@change</code></strong>: Se activa cuando el valor de un campo de formulario cambia.</p>
</li>
<li>
<p><strong><code>@submit</code></strong>: Se utiliza en formularios para ejecutar acciones cuando se envía el formulario.</p>
</li>
<li>
<p><strong><code>@mouseover</code></strong>: Detecta cuando el puntero se coloca sobre un elemento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplo de uso de varios eventos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;form @submit.prevent="handleSubmit"&gt;
    &lt;label&gt;
      Nombre:
      &lt;input v-model="name" @change="handleChange" /&gt;
    &lt;/label&gt;
    &lt;button type="submit"&gt;Enviar&lt;/button&gt;
  &lt;/form&gt;
  &lt;div @mouseover="handleMouseOver"&gt;
    Pasa el mouse sobre mí
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref } from 'vue';

  const name = ref('');
  const hoverMessage = ref('No estás sobre el div');

  const handleChange = () =&gt; {
    console.log(`Nombre actualizado a: ${name.value}`);
  };

  const handleSubmit = () =&gt; {
    console.log(`Formulario enviado con nombre: ${name.value}`);
  };

  const handleMouseOver = () =&gt; {
    hoverMessage.value = '¡Estás sobre el div!';
  };
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><strong><code>@change</code></strong> se activa al modificar el campo de entrada, registrando el cambio.</p>
</li>
<li>
<p><strong><code>@submit</code></strong> se usa en el formulario y, con <code>.prevent</code>, evita el recargo de la página, llamando a <code>handleSubmit</code>.</p>
</li>
<li>
<p><strong><code>@mouseover</code></strong> detecta cuando el puntero pasa sobre el <code>div</code>, actualizando el mensaje en <code>hoverMessage</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Estos eventos permiten manejar múltiples interacciones del usuario de forma declarativa y reactiva en el componente.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ciclo_de_vida_de_los_componentes_y_hooks_principales">Ciclo de vida de los componentes y hooks principales</h3>
<div class="paragraph">
<p>En Vue 3, los componentes pasan por una serie de etapas llamadas "hooks del ciclo de vida" que permiten ejecutar lógica en momentos específicos de su creación, actualización y destrucción. Con la Composition API, estos hooks son funciones importadas que pueden ser usadas dentro de <code>setup</code>.</p>
</div>
<div class="sect3">
<h4 id="_ciclo_de_vida_de_un_componente_en_vue_3">Ciclo de vida de un componente en Vue 3</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Creación</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>onBeforeMount</code>: antes de que el componente se inserte en el DOM.</p>
</li>
<li>
<p><code>onMounted</code>: una vez que el componente se ha insertado en el DOM.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Actualización</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>onBeforeUpdate</code>: antes de actualizar el DOM con nuevos cambios reactivos.</p>
</li>
<li>
<p><code>onUpdated</code>: después de actualizar el DOM con los cambios.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Destrucción</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><code>onBeforeUnmount</code>: justo antes de que el componente se retire del DOM.</p>
</li>
<li>
<p><code>onUnmounted</code>: una vez que el componente ha sido retirado del DOM.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_los_hooks_del_ciclo_de_vida_del_componente">Uso de los hooks del ciclo de vida del componente</h4>
<div class="paragraph">
<p>A continuación, se muestra cómo utilizar cada hook en un componente con la Composition API. Este componente registra en la consola el momento en que se activa cada hook.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue';

  const count = ref(0);

  const increment = () =&gt; {
    count.value++;
  };

  // Hooks del ciclo de vida
  onBeforeMount(() =&gt; {
    console.log('El componente está a punto de montarse');
  });

  onMounted(() =&gt; {
    console.log('El componente se ha montado en el DOM');
  });

  onBeforeUpdate(() =&gt; {
    console.log('El componente está a punto de actualizarse');
  });

  onUpdated(() =&gt; {
    console.log('El componente se ha actualizado');
  });

  onBeforeUnmount(() =&gt; {
    console.log('El componente está a punto de desmontarse');
  });

  onUnmounted(() =&gt; {
    console.log('El componente se ha desmontado');
  });
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_explicación_de_cada_hook">Explicación de cada hook</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong><code>onBeforeMount</code></strong>: Se ejecuta antes de que el componente se inserte en el DOM. Útil para configurar datos o preparar el estado antes de la inserción.</p>
</li>
<li>
<p><strong><code>onMounted</code></strong>: Se ejecuta después de que el componente se haya montado. Ideal para realizar tareas que requieren acceso al DOM, como llamadas a APIs o inicialización de librerías que dependen del DOM.</p>
</li>
<li>
<p><strong><code>onBeforeUpdate</code></strong>: Se ejecuta antes de que el componente actualice el DOM debido a cambios en los datos reactivos. Puede ser útil para calcular valores previos o tomar decisiones antes de una actualización.</p>
</li>
<li>
<p><strong><code>onUpdated</code></strong>: Se ejecuta después de que el DOM haya sido actualizado. Útil para ejecutar lógica que dependa del DOM actualizado.</p>
</li>
<li>
<p><strong><code>onBeforeUnmount</code></strong>: Se ejecuta justo antes de que el componente se elimine del DOM. Ideal para limpiar datos o eventos.</p>
</li>
<li>
<p><strong><code>onUnmounted</code></strong>: Se ejecuta cuando el componente ha sido eliminado del DOM. Útil para realizar limpieza final, como cancelar suscripciones o destruir instancias de terceros.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Estos hooks ayudan a controlar y optimizar el flujo del ciclo de vida de los componentes en Vue 3, permitiendo ejecutar lógica en momentos clave.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_un_componente_con_todos_los_hooks_del_ciclo_de_vida">Ejemplo de un componente con todos los hooks del ciclo de vida</h4>
<div class="paragraph">
<p>En este ejemplo, se utiliza un componente que muestra y actualiza un contador. Cada hook del ciclo de vida ejecuta una acción específica que se registra en la consola, lo que permite observar cómo y cuándo cada hook interactúa durante el ciclo de vida del componente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Contador de Ejemplo&lt;/h2&gt;
    &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted } from 'vue';

  const count = ref(0);

  const increment = () =&gt; {
    count.value++;
  };

  // Ejecución de cada hook del ciclo de vida
  onBeforeMount(() =&gt; {
    console.log('onBeforeMount: El componente está a punto de montarse');
  });

  onMounted(() =&gt; {
    console.log('onMounted: El componente se ha montado en el DOM');
  });

  onBeforeUpdate(() =&gt; {
    console.log('onBeforeUpdate: El componente está a punto de actualizarse');
  });

  onUpdated(() =&gt; {
    console.log('onUpdated: El componente se ha actualizado');
  });

  onBeforeUnmount(() =&gt; {
    console.log('onBeforeUnmount: El componente está a punto de desmontarse');
  });

  onUnmounted(() =&gt; {
    console.log('onUnmounted: El componente se ha desmontado');
  });
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_3_componentes_en_vue_3">Módulo 3: Componentes en Vue 3</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_creación_y_uso_de_componentes_básicos">Creación y uso de componentes básicos</h3>
<div class="paragraph">
<p>En Vue 3, los componentes permiten encapsular funcionalidad, reutilizar código y estructurar aplicaciones de manera modular. La creación de un componente básico implica definir una plantilla (<code>template</code>), lógica (<code>script</code>), y, opcionalmente, estilos (<code>style</code>). A continuación, se explica cómo crear y utilizar componentes en la Composition API de Vue 3.</p>
</div>
<div class="sect3">
<h4 id="_paso_1_crear_un_componente_básico">Paso 1: Crear un componente básico</h4>
<div class="paragraph">
<p>Para crear un componente en Vue 3, primero definimos su estructura en un archivo <code>.vue</code>. Este ejemplo muestra un componente llamado <code>Counter.vue</code> que mantiene un contador simple y lo incrementa al hacer clic en un botón.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Contador: {{ count }}&lt;/h3&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref } from 'vue';

  const count = ref(0);

  const increment = () =&gt; {
    count.value++;
  };
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- <strong><code>count</code></strong> es una variable reactiva que mantiene el estado del contador.
- <strong><code>increment</code></strong> es un método que incrementa el valor de <code>count</code> cuando se hace clic en el botón.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paso_2_importar_y_usar_el_componente_en_otro_componente_o_página">Paso 2: Importar y usar el componente en otro componente o página</h4>
<div class="paragraph">
<p>Una vez creado el componente <code>Counter.vue</code>, podemos importarlo y utilizarlo dentro de otros componentes o en una página principal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Ejemplo de Uso de un Componente Básico&lt;/h2&gt;
    &lt;Counter /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import Counter from './Counter.vue';
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este caso:</div>
<ul>
<li>
<p>El componente <code>Counter</code> se importa y utiliza dentro de la plantilla.</p>
</li>
<li>
<p>Se usa como una etiqueta HTML (<code>&lt;Counter /&gt;</code>), lo que permite que el componente encapsule su funcionalidad y estado sin afectar a otros elementos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_paso_3_pasar_props_a_un_componente">Paso 3: Pasar props a un componente</h4>
<div class="paragraph">
<p>Los componentes en Vue aceptan datos a través de "props" (propiedades), que permiten que el componente reciba valores desde su componente padre.</p>
</div>
<div class="paragraph">
<p>Modificamos el componente <code>Counter.vue</code> para aceptar un valor inicial a través de una prop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Contador: {{ count }}&lt;/h3&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref, defineProps, watch } from 'vue';

const props = defineProps&lt;{ initialCount: number }&gt;();

const count = ref(props.initialCount);

const increment = () =&gt; {
  count.value++;
};

// Opcional: Vigilar cambios en initialCount para actualizar count
watch(() =&gt; props.initialCount, (newVal) =&gt; {
  count.value = newVal;
});
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora <code>Counter.vue</code> acepta una prop llamada <code>initialCount</code>, la cual permite inicializar el contador con un valor específico. Podemos usarlo así en el componente principal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Ejemplo de Componente con Propiedades&lt;/h2&gt;
    &lt;Counter :initialCount="5" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import Counter from './Counter.vue';
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí, el contador de <code>Counter</code> comenzará en <code>5</code> gracias a la prop <code>initialCount</code>. Las props permiten parametrizar los componentes, haciéndolos más flexibles y reutilizables.</p>
</div>
</div>
<div class="sect3">
<h4 id="_paso_4_emitir_eventos_desde_un_componente">Paso 4: Emitir eventos desde un componente</h4>
<div class="paragraph">
<p>Los componentes pueden comunicarse con su componente padre mediante eventos personalizados. Para emitir un evento, se utiliza <code>emit</code> dentro del componente hijo.</p>
</div>
<div class="paragraph">
<p>Agregamos la funcionalidad de emitir el valor del contador cada vez que se actualice en <code>Counter.vue</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Contador: {{ count }}&lt;/h3&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
  import { ref, defineProps, defineEmits } from 'vue';

  const props = defineProps&lt;{ initialCount: number }&gt;();
  const emit = defineEmits&lt;{
    (e: 'update:count', value: number): void;
  }&gt;();

  const count = ref(props.initialCount);

  const increment = () =&gt; {
    count.value++;
    emit('update:count', count.value);
  };
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora el componente <code>Counter</code> emite un evento <code>update:count</code> cada vez que se incrementa el contador. En el componente padre, podemos escuchar este evento y realizar acciones adicionales:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Ejemplo de Componente con Eventos&lt;/h2&gt;
    &lt;Counter :initialCount="5" @update:count="handleCountUpdate" /&gt;
    &lt;p&gt;Valor actual del contador: {{ currentCount }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';
import Counter from './Counter.vue';

const currentCount = ref(0);

const handleCountUpdate = (value: number) =&gt; {
  currentCount.value = value;
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><strong><code>@update:count="handleCountUpdate"</code></strong> escucha el evento emitido por <code>Counter</code> y actualiza <code>currentCount</code>.</p>
</li>
<li>
<p>Esto permite que el componente padre reaccione a los cambios realizados en el hijo, manteniendo los valores sincronizados.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Este flujo de creación y comunicación entre componentes es la base de la composición modular en Vue 3, facilitando la reutilización y escalabilidad en aplicaciones complejas.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comunicación_entre_componentes_con_props_y_emit">Comunicación entre componentes con <code>props</code> y <code>$emit</code></h3>
<div class="paragraph">
<p>En Vue 3, la comunicación entre componentes padre e hijo se realiza principalmente usando <code>props</code> para pasar datos del padre al hijo, y <code>$emit</code> para que el hijo envíe eventos de vuelta al padre. Esta comunicación unidireccional y eventos permite que los componentes se mantengan independientes y reutilizables, compartiendo datos solo cuando sea necesario.</p>
</div>
<div class="sect3">
<h4 id="_usando_props_para_pasar_datos_al_componente_hijo">Usando <code>props</code> para pasar datos al componente hijo</h4>
<div class="paragraph">
<p>Las <code>props</code> permiten que el componente padre pase datos al componente hijo. Para recibirlas, se definen en el hijo usando <code>defineProps</code>.</p>
</div>
<div class="paragraph">
<p>Ejemplo de un componente hijo <code>DisplayMessage.vue</code> que recibe un mensaje como prop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Mensaje recibido: {{ message }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { defineProps } from 'vue';

const props = defineProps&lt;{ message: string }&gt;();
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este componente espera una prop <code>message</code> que mostrará en su plantilla. Ahora, el componente padre puede pasar un valor a esta prop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Componente Padre&lt;/h2&gt;
    &lt;DisplayMessage message="¡Hola desde el componente padre!" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import DisplayMessage from './DisplayMessage.vue';
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>El componente <code>DisplayMessage</code> recibe el mensaje desde el padre y lo muestra en su vista.</p>
</li>
<li>
<p>Las props permiten parametrizar los componentes hijos y hacerlos más reutilizables.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_emitiendo_eventos_desde_el_componente_hijo_con_emit">Emitiendo eventos desde el componente hijo con <code>$emit</code></h4>
<div class="paragraph">
<p>Cuando el componente hijo necesita enviar información al padre, puede hacerlo emitiendo eventos. Esto se logra usando <code>defineEmits</code> para definir el evento y luego llamando a <code>$emit</code> cuando sea necesario.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, un componente hijo <code>Counter.vue</code> que emite el valor actualizado de un contador cada vez que se incrementa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref, defineEmits } from 'vue';

const count = ref(0);
const emit = defineEmits&lt;{
  (e: 'update:count', value: number): void;
}&gt;();

const increment = () =&gt; {
  count.value++;
  emit('update:count', count.value);
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- <code>emit('update:count', count.value)</code> emite un evento <code>update:count</code> cada vez que se incrementa el contador, pasando el valor actual de <code>count</code>.
- El componente padre puede escuchar este evento y reaccionar a él.</p>
</div>
<div class="paragraph">
<p>En el componente padre, escuchamos el evento <code>update:count</code> y actualizamos el estado con el valor emitido:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Componente Padre con Evento&lt;/h2&gt;
    &lt;Counter @update:count="handleCountUpdate" /&gt;
    &lt;p&gt;Valor del contador en el padre: {{ currentCount }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';
import Counter from './Counter.vue';

const currentCount = ref(0);

const handleCountUpdate = (value: number) =&gt; {
  currentCount.value = value;
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aquí:
- <strong><code>@update:count="handleCountUpdate"</code></strong> escucha el evento emitido por <code>Counter</code> y ejecuta la función <code>handleCountUpdate</code>.
- <code>handleCountUpdate</code> actualiza el valor de <code>currentCount</code>, manteniendo el padre sincronizado con el hijo.</p>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_v_model_personalizado_en_componentes_para_simplificar_props_y_emit">Uso de <code>v-model</code> personalizado en componentes para simplificar <code>props</code> y <code>$emit</code></h4>
<div class="paragraph">
<p>Vue 3 permite utilizar <code>v-model</code> en componentes personalizados, lo que simplifica el uso de <code>props</code> y <code>emit</code>. Para implementar un <code>v-model</code> en un componente, configuramos la prop <code>modelValue</code> y emitimos <code>update:modelValue</code> cuando el valor cambia.</p>
</div>
<div class="paragraph">
<p>Modificamos el componente <code>Counter.vue</code> para que utilice <code>v-model</code> en lugar de <code>props</code> y <code>$emit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Contador: {{ modelValue }}&lt;/p&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { defineProps, defineEmits } from 'vue';

const props = defineProps&lt;{ modelValue: number }&gt;();
const emit = defineEmits&lt;{
  (e: 'update:modelValue', value: number): void;
}&gt;();

const increment = () =&gt; {
  emit('update:modelValue', props.modelValue + 1);
};
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el componente padre, se puede utilizar <code>v-model</code> para enlazar el valor del contador directamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Componente Padre con `v-model`&lt;/h2&gt;
    &lt;Counter v-model="parentCount" /&gt;
    &lt;p&gt;Valor del contador en el padre: {{ parentCount }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';
import Counter from './Counter.vue';

const parentCount = ref(0);
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><strong><code>v-model="parentCount"</code></strong> establece un enlace bidireccional entre <code>parentCount</code> en el componente padre y <code>modelValue</code> en el hijo.</p>
</li>
<li>
<p>Al cambiar el valor en el componente hijo, se actualiza automáticamente el valor en el padre, simplificando la comunicación.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El uso de <code>props</code>, <code>$emit</code>, y <code>v-model</code> permite un flujo de datos claro y reactivo entre componentes en Vue 3, manteniendo la arquitectura de la aplicación limpia y fácil de mantener.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_scoped_slots_y_render_functions">Scoped Slots y Render Functions</h3>
<div class="paragraph">
<p>Vue 3 permite una mayor flexibilidad en la personalización de componentes a través de <strong>slots</strong> y <strong>render functions</strong>. Los <strong>slots</strong> se utilizan para inyectar contenido dinámico en un componente desde el componente padre, mientras que los <strong>scoped slots</strong> (slots con alcance) permiten pasar datos del componente hijo al slot, logrando una mayor personalización. Las <strong>render functions</strong>, por otro lado, ofrecen una forma programática de definir la estructura de un componente usando JavaScript, en lugar de un template.</p>
</div>
<div class="sect3">
<h4 id="_uso_de_scoped_slots">Uso de Scoped Slots</h4>
<div class="paragraph">
<p>Los scoped slots son slots que reciben datos del componente hijo y permiten que el componente padre los utilice dentro del slot. Esto es útil para crear componentes más flexibles y reutilizables.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, en un componente <code>UserList.vue</code> que muestra una lista de usuarios, podemos definir un scoped slot para permitir que el componente padre personalice la visualización de cada usuario.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Lista de Usuarios&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li v-for="user in users" :key="user.id"&gt;
        &lt;slot :user="user"&gt;
          {{ user.name }} &lt;!-- Slot predeterminado en caso de no ser personalizado --&gt;
        &lt;/slot&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';

const users = ref([
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
]);
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- El scoped slot <code>:user="user"</code> pasa el objeto <code>user</code> al slot.
- Si el componente padre no proporciona un slot personalizado, se muestra <code>user.name</code> por defecto.</p>
</div>
<div class="paragraph">
<p>En el componente padre, se puede personalizar cómo se presenta cada usuario usando el scoped slot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Componente Padre&lt;/h2&gt;
    &lt;UserList&gt;
      &lt;template #default="{ user }"&gt;
        &lt;strong&gt;ID:&lt;/strong&gt; {{ user.id }}, &lt;strong&gt;Nombre:&lt;/strong&gt; {{ user.name }}
      &lt;/template&gt;
    &lt;/UserList&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import UserList from './UserList.vue';
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>El componente padre define el contenido del slot usando <code>#default="{ user }"</code>, accediendo a <code>user</code> directamente.</p>
</li>
<li>
<p>Esto permite mostrar tanto el ID como el nombre del usuario, en lugar de solo el nombre, haciendo el componente más flexible.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_render_functions">Uso de Render Functions</h4>
<div class="paragraph">
<p>Las render functions permiten definir la estructura del componente directamente en JavaScript, lo cual es útil para casos avanzados en los que se requiere lógica compleja de renderizado o control total sobre el DOM virtual. En Vue 3, las render functions se definen en el bloque <code>script</code> del componente.</p>
</div>
<div class="paragraph">
<p>A continuación, se muestra un ejemplo de un componente <code>DynamicButton.vue</code> que renderiza un botón con texto y atributos personalizados.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;script lang="ts" setup&gt;
import { defineComponent, h } from 'vue';

export default defineComponent({
  props: {
    label: {
      type: String,
      required: true
    },
    onClick: {
      type: Function,
      required: true
    }
  },
  setup(props) {
    return () =&gt;
      h(
        'button',
        {
          onClick: props.onClick,
          style: { padding: '10px', fontSize: '16px', cursor: 'pointer' }
        },
        props.label
      );
  }
});
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- La función <code>h</code> (hyperscript) se usa para crear el elemento <code>button</code>.
- Se establecen las propiedades y eventos directamente en la función <code>h</code>, incluyendo un evento <code>onClick</code> que llama a <code>props.onClick</code> cuando se hace clic en el botón.
- <code>props.label</code> se usa como texto del botón.</p>
</div>
<div class="paragraph">
<p>En el componente padre, se puede usar <code>DynamicButton</code> y pasarle propiedades:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;DynamicButton label="Haz clic aquí" :onClick="handleClick" /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';
import DynamicButton from './DynamicButton.vue';

const handleClick = () =&gt; {
  console.log('¡Botón clicado!');
};
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composición_de_componentes_y_reutilización_de_lógica">Composición de componentes y reutilización de lógica</h3>
<div class="paragraph">
<p>Vue 3 presenta una manera poderosa y flexible de reutilizar lógica y estado en los componentes mediante la <strong>Composition API</strong>. La reutilización de lógica se logra usando <strong>composables</strong>, que son funciones reutilizables que encapsulan lógica y estado, separándolos del componente que los consume. Esta técnica permite crear una estructura modular y escalable en aplicaciones complejas.</p>
</div>
<div class="sect3">
<h4 id="_creando_un_composable">Creando un Composable</h4>
<div class="paragraph">
<p>Un composable es una función que encapsula lógica reutilizable. Por convención, los composables comienzan con <code>use</code> (por ejemplo, <code>useCounter</code>).</p>
</div>
<div class="paragraph">
<p>A continuación, se muestra un ejemplo de un composable <code>useCounter.js</code> que administra la lógica de un contador.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref } from 'vue';

export function useCounter(initialValue = 0) {
  const count = ref(initialValue);

  const increment = () =&gt; {
    count.value++;
  };

  const decrement = () =&gt; {
    count.value--;
  };

  return { count, increment, decrement };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este composable:
- Define <code>count</code> como una propiedad reactiva usando <code>ref</code>.
- Incluye las funciones <code>increment</code> y <code>decrement</code> para modificar el valor de <code>count</code>.
- Retorna <code>count</code>, <code>increment</code>, y <code>decrement</code>, lo que permite acceder a estos dentro de cualquier componente que utilice <code>useCounter</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_usando_un_composable_en_un_componente">Usando un Composable en un Componente</h4>
<div class="paragraph">
<p>Una vez que hemos creado el composable, podemos usarlo en cualquier componente para acceder a la lógica y el estado encapsulados.</p>
</div>
<div class="paragraph">
<p>En el siguiente ejemplo, el componente <code>CounterComponent.vue</code> utiliza <code>useCounter</code> para mostrar y actualizar un contador.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Valor del contador: {{ count }}&lt;/h3&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
    &lt;button @click="decrement"&gt;Decrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useCounter } from './useCounter';

const { count, increment, decrement } = useCounter(10);
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- <code>useCounter</code> se importa y se llama en la sección <code>setup</code>.
- <code>count</code>, <code>increment</code>, y <code>decrement</code> están disponibles en el template, permitiendo que el contador se muestre y se actualice según la lógica definida en el composable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_composición_de_varios_componentes_en_vue_3">Composición de varios Componentes en Vue 3</h4>
<div class="paragraph">
<p>La composición de varios componentes en Vue 3 permite construir interfaces complejas a partir de componentes más pequeños y reutilizables. Utilizando la Composition API con la sintaxis <code>&lt;script lang="ts" setup&gt;</code>, se facilita la gestión de la lógica compartida y la comunicación entre componentes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comunicación_entre_componentes_padre_e_hijo">Comunicación entre Componentes Padre e Hijo</h3>
<div class="paragraph">
<p>La comunicación entre componentes padre e hijo es fundamental para la composición efectiva. El componente padre puede pasar datos al hijo mediante <strong>props</strong> y el hijo puede emitir eventos al padre.</p>
</div>
<div class="listingblock">
<div class="title">Componente Hijo</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Hijo --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Mensaje del Padre: {{ message }}&lt;/p&gt;
    &lt;button @click="sendUpdate"&gt;Enviar Actualización&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { defineProps, defineEmits } from 'vue'

const props = defineProps&lt;{ message: string }&gt;()
const emit = defineEmits&lt;{ (e: 'update', newMessage: string): void }&gt;()

const sendUpdate = () =&gt; {
  emit('update', 'Nuevo Mensaje desde el Hijo')
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Componente Padre</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Padre --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Componente Padre&lt;/h1&gt;
    &lt;ChildComponent :message="parentMessage" @update="handleUpdate" /&gt;
    &lt;p&gt;Mensaje Actualizado: {{ parentMessage }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

const parentMessage = ref('Hola desde el Padre')

const handleUpdate = (newMessage: string) =&gt; {
  parentMessage.value = newMessage
}
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uso_de_slots_para_mayor_flexibilidad">Uso de Slots para Mayor Flexibilidad</h3>
<div class="paragraph">
<p>Los <strong>slots</strong> en Vue 3 permiten a los componentes padres inyectar contenido en los componentes hijos, proporcionando una mayor flexibilidad y reutilización. Los slots pueden ser utilizados para definir áreas de contenido que pueden ser personalizadas por el componente padre.</p>
</div>
<div class="sect3">
<h4 id="_slots_básicos">Slots Básicos</h4>
<div class="paragraph">
<p>Un slot básico permite al componente padre insertar contenido en una ubicación específica del componente hijo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Card --&gt;
&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;slot&gt;Contenido por Defecto&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Padre --&gt;
&lt;template&gt;
  &lt;Card&gt;
    &lt;p&gt;Este es el contenido personalizado del card.&lt;/p&gt;
  &lt;/Card&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import Card from './Card.vue'
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_slots_nombrados">Slots Nombrados</h4>
<div class="paragraph">
<p>Los slots nombrados permiten definir múltiples áreas de contenido personalizables dentro de un componente hijo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Card --&gt;
&lt;template&gt;
  &lt;div class="card"&gt;
    &lt;header&gt;
      &lt;slot name="header"&gt;Encabezado por Defecto&lt;/slot&gt;
    &lt;/header&gt;
    &lt;main&gt;
      &lt;slot&gt;Contenido por Defecto&lt;/slot&gt;
    &lt;/main&gt;
    &lt;footer&gt;
      &lt;slot name="footer"&gt;Pie de Página por Defecto&lt;/slot&gt;
    &lt;/footer&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Padre --&gt;
&lt;template&gt;
  &lt;Card&gt;
    &lt;template #header&gt;
      &lt;h2&gt;Título Personalizado&lt;/h2&gt;
    &lt;/template&gt;
    &lt;p&gt;Este es el contenido personalizado del card.&lt;/p&gt;
    &lt;template #footer&gt;
      &lt;button&gt;Acción&lt;/button&gt;
    &lt;/template&gt;
  &lt;/Card&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import Card from './Card.vue'
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_slots_dinámicos">Slots Dinámicos</h4>
<div class="paragraph">
<p>Los slots dinámicos permiten pasar contenido dinámico a los componentes hijos, lo que es útil para crear componentes altamente reutilizables.</p>
</div>
<div class="listingblock">
<div class="title">Componente List</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente List --&gt;
&lt;template&gt;
  &lt;ul&gt;
    &lt;li v-for="item in items" :key="item.id"&gt;
      &lt;slot :item="item"&gt;{{ item.name }}&lt;/slot&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { defineProps } from 'vue'

const props = defineProps&lt;{ items: Array&lt;{ id: number, name: string }&gt; }&gt;()
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Componente Padre</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Padre --&gt;
&lt;template&gt;
  &lt;List :items="items"&gt;
    &lt;template #default="{ item }"&gt;
      &lt;strong&gt;{{ item.name }}&lt;/strong&gt;
    &lt;/template&gt;
  &lt;/List&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import List from './List.vue'

const items = [
  { id: 1, name: 'Item 1' },
  { id: 2, name: 'Item 2' },
]
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_composición_de_componentes_con_provideinject">Composición de Componentes con Provide/Inject</h3>
<div class="paragraph">
<p>La directiva <strong>provide/inject</strong> permite compartir datos entre componentes sin tener que pasar props a través de múltiples niveles de la jerarquía de componentes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Ancestro --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Componente Ancestro&lt;/h1&gt;
    &lt;DescendantComponent /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { provide, ref } from 'vue'
import DescendantComponent from './DescendantComponent.vue'

const sharedState = ref('Estado Compartido')
provide('sharedState', sharedState)
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!-- Componente Descendiente --&gt;
&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Componente Descendiente&lt;/h2&gt;
    &lt;p&gt;Estado Compartido: {{ sharedState }}&lt;/p&gt;
    &lt;button @click="updateState"&gt;Actualizar Estado&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { inject, ref } from 'vue'

const sharedState = inject&lt;Ref&lt;string&gt;&gt;('sharedState')
if (!sharedState) {
  throw new Error('sharedState no está disponible')
}

const updateState = () =&gt; {
  sharedState.value = 'Estado Actualizado desde el Descendiente'
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_beneficios_de_la_composición_y_la_reutilización_de_lógica">Beneficios de la Composición y la Reutilización de Lógica</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Modularidad</strong>: Los composables permiten dividir la lógica en unidades pequeñas y reutilizables.</p>
</li>
<li>
<p><strong>Escalabilidad</strong>: Facilita el mantenimiento y escalabilidad de aplicaciones complejas.</p>
</li>
<li>
<p><strong>Reutilización</strong>: La lógica encapsulada en composables puede ser usada en cualquier componente sin duplicación de código.</p>
</li>
<li>
<p><strong>Claridad</strong>: El código se organiza de manera clara, separando la lógica de la estructura del componente.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_introducción_a_la_api_de_composición_setup_reactive_y_ref">Introducción a la API de Composición: <code>setup()</code>, <code>reactive()</code>, y <code>ref()</code></h3>
<div class="paragraph">
<p>Vue 3 introduce la <strong>API de Composición</strong>, una forma flexible y escalable de organizar la lógica en los componentes. Esta API, basada en el método <code>setup()</code>, permite que las propiedades reactivas y la lógica se definan en un solo lugar, proporcionando mayor modularidad y reutilización en aplicaciones complejas.</p>
</div>
<div class="sect3">
<h4 id="_el_método_setup">El método <code>setup()</code></h4>
<div class="paragraph">
<p>El método <code>setup()</code> es el corazón de la API de Composición y se ejecuta antes del ciclo de vida del componente. Aquí es donde se define el estado, se crean las funciones y se organiza la lógica del componente. Todo lo que retorna <code>setup()</code> estará disponible en el template del componente.</p>
</div>
<div class="paragraph">
<p>Ejemplo de un componente básico utilizando <code>setup()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Contador: {{ count }}&lt;/h3&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';

const count = ref(0);

function increment() {
  count.value++;
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>count</code> y <code>increment</code> se definen en <code>setup()</code> y están disponibles en el template.</p>
</li>
<li>
<p><code>ref(0)</code> se usa para declarar <code>count</code> como un valor reactivo, permitiendo que los cambios se reflejen en la interfaz.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ref_variables_reactivas_con_referencias"><code>ref()</code>: Variables reactivas con referencias</h4>
<div class="paragraph">
<p><code>ref()</code> es una función que permite crear una variable reactiva en Vue 3. Los valores reactivos creados con <code>ref()</code> se almacenan en la propiedad <code>.value</code>, permitiendo el seguimiento de los cambios en el estado y la actualización automática del DOM.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, una variable reactiva de texto puede definirse así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;script lang="ts" setup&gt;
import { ref } from 'vue';

const message = ref('Hola, Vue 3!');
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando <code>message.value</code> cambia, Vue actualiza automáticamente cualquier referencia a <code>message</code> en el DOM.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reactive_objetos_reactivos_completos"><code>reactive()</code>: Objetos reactivos completos</h4>
<div class="paragraph">
<p>Mientras <code>ref()</code> es ideal para valores simples, <code>reactive()</code> permite crear objetos completos que reaccionan a los cambios de forma profunda, es decir, Vue hará seguimiento a cualquier cambio dentro del objeto y actualizará el DOM en consecuencia.</p>
</div>
<div class="paragraph">
<p>Ejemplo de un objeto reactivo utilizando <code>reactive()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;script lang="ts" setup&gt;
import { reactive } from 'vue';

const user = reactive({
  name: 'Alice',
  age: 25
});

function incrementAge() {
  user.age++;
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>user</code> es un objeto reactivo, y cualquier cambio en sus propiedades se reflejará automáticamente en la vista.</p>
</li>
<li>
<p><code>reactive()</code> permite simplificar el acceso a las propiedades (no es necesario usar <code>.value</code> como en <code>ref()</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_comparación_entre_ref_y_reactive">Comparación entre <code>ref()</code> y <code>reactive()</code></h4>
<div class="ulist">
<ul>
<li>
<p><strong><code>ref()</code></strong>: Ideal para valores primitivos (como números o cadenas). Almacena su valor en <code>.value</code> y es útil para crear propiedades reactivas independientes.</p>
</li>
<li>
<p><strong><code>reactive()</code></strong>: Mejor para objetos y estructuras de datos más complejas. Permite crear reactividad profunda sin necesidad de acceder a <code>.value</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_práctico_combinando_ref_y_reactive">Ejemplo práctico: Combinando <code>ref()</code> y <code>reactive()</code></h4>
<div class="paragraph">
<p>A continuación, un ejemplo que combina <code>ref()</code> y <code>reactive()</code> en un mismo componente para administrar diferentes tipos de datos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Información del Usuario&lt;/h3&gt;
    &lt;p&gt;Nombre: {{ user.name }}&lt;/p&gt;
    &lt;p&gt;Edad: {{ user.age }}&lt;/p&gt;
    &lt;button @click="incrementAge"&gt;Incrementar Edad&lt;/button&gt;

    &lt;h3&gt;Contador&lt;/h3&gt;
    &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
    &lt;button @click="incrementCount"&gt;Incrementar Contador&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref, reactive } from 'vue';

const count = ref(0);
const user = reactive({
  name: 'Alice',
  age: 25
});

function incrementCount() {
  count.value++;
}

function incrementAge() {
  user.age++;
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>count</code> es una variable simple y usa <code>ref()</code>, mientras que <code>user</code> es un objeto y utiliza <code>reactive()</code>.</p>
</li>
<li>
<p>Ambos valores son reactivamente actualizables y reflejarán sus cambios en el template.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p><strong><code>setup()</code></strong>: Permite definir el estado y lógica del componente antes de que se inicie el ciclo de vida.</p>
</li>
<li>
<p><strong><code>ref()</code></strong>: Crea variables reactivas, ideales para valores simples, con la propiedad <code>.value</code>.</p>
</li>
<li>
<p><strong><code>reactive()</code></strong>: Crea objetos reactivos que permiten un seguimiento profundo de las propiedades.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_4_manejo_de_estados_con_pinia">Módulo 4: Manejo de Estados con Pinia</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introducción_a_pinia_como_alternativa_a_vuex">Introducción a Pinia como alternativa a Vuex</h3>
<div class="paragraph">
<p>Pinia es una librería de gestión de estado para Vue 3, diseñada como una alternativa más ligera, flexible y con mejor integración en el ecosistema moderno de Vue que Vuex. Al igual que Vuex, Pinia permite centralizar y gestionar el estado de la aplicación en un solo lugar, facilitando la comunicación entre componentes. Sin embargo, Pinia aprovecha las mejoras en Vue 3 y la Composition API para ofrecer una experiencia de desarrollo más fluida y sencilla.</p>
</div>
<div class="sect3">
<h4 id="_ventajas_de_pinia_sobre_vuex">Ventajas de Pinia sobre Vuex</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Simplicidad</strong>: Pinia tiene una sintaxis más sencilla y menos configuración.</p>
</li>
<li>
<p><strong>Reactividad</strong>: Pinia utiliza <code>ref()</code> y <code>reactive()</code>, permitiendo un estado completamente reactivo.</p>
</li>
<li>
<p><strong>Tipado Mejorado</strong>: Pinia aprovecha TypeScript y ofrece un mejor soporte de tipado que Vuex.</p>
</li>
<li>
<p><strong>Soporte para Composition API</strong>: Pinia se integra perfectamente con la Composition API, mejorando la reutilización de lógica y el trabajo con módulos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_de_pinia">Instalación de Pinia</h4>
<div class="paragraph">
<p>Para instalar Pinia, basta con ejecutar el siguiente comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">npm install pinia</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez instalado, se configura en la instancia principal de Vue en <code>main.ts</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { createApp } from 'vue';
import { createPinia } from 'pinia';
import App from './App.vue';

const app = createApp(App);
const pinia = createPinia();

app.use(pinia);
app.mount('#app');</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creación_de_una_store_básica_en_pinia">Creación de una store básica en Pinia</h4>
<div class="paragraph">
<p>Las stores en Pinia se definen mediante funciones que retornan el estado y métodos para modificarlo. A continuación, se muestra un ejemplo de una store de contador (<code>useCounterStore</code>) utilizando <code>defineStore</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useCounterStore = defineStore('counter', () =&gt; {
  const count = ref(0);

  function increment() {
    count.value++;
  }

  function decrement() {
    count.value--;
  }

  return { count, increment, decrement };
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>defineStore</code> crea una store llamada <code>counter</code> que contiene el estado <code>count</code> y dos métodos (<code>increment</code> y <code>decrement</code>).</p>
</li>
<li>
<p><code>ref()</code> se utiliza para que <code>count</code> sea reactivo y sus cambios se reflejen automáticamente en los componentes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_usando_una_store_en_un_componente">Usando una store en un componente</h4>
<div class="paragraph">
<p>Para acceder a una store en un componente, primero se importa y se instancia. A continuación, se muestra un ejemplo de cómo usar <code>useCounterStore</code> en un componente <code>CounterComponent.vue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;Contador: {{ counter.count }}&lt;/h3&gt;
    &lt;button @click="counter.increment"&gt;Incrementar&lt;/button&gt;
    &lt;button @click="counter.decrement"&gt;Decrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useCounterStore } from './stores/counter';

const counter = useCounterStore();
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este componente:</div>
<ul>
<li>
<p><code>useCounterStore</code> se importa y se usa para acceder a la instancia de la store.</p>
</li>
<li>
<p>Los métodos y estado de la store (<code>count</code>, <code>increment</code>, <code>decrement</code>) están disponibles en el template y se actualizan reactivamente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estado_derivado_y_getters_en_pinia">Estado Derivado y Getters en Pinia</h4>
<div class="paragraph">
<p>Pinia es una biblioteca de gestión de estado para Vue que proporciona una API simple y poderosa para manejar el estado global de la aplicación. Los <strong>getters</strong> en Pinia se utilizan para derivar estado basado en el estado almacenado en el store, similar a las propiedades computadas en los componentes Vue.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definiendo_un_store_con_getters">Definiendo un Store con Getters</h3>
<div class="paragraph">
<p>Para definir un store con getters en Pinia, primero se crea el store y luego se añaden los getters que derivan el estado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () =&gt; ({
    firstName: 'John',
    lastName: 'Doe',
    age: 30,
  }),
  getters: {
    fullName: (state) =&gt; `${state.firstName} ${state.lastName}`,
    isAdult: (state) =&gt; state.age &gt;= 18,
  },
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_usando_getters_en_componentes">Usando Getters en Componentes</h3>
<div class="paragraph">
<p>Una vez definidos los getters en el store, se pueden utilizar en los componentes Vue para acceder al estado derivado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Nombre Completo: {{ fullName }}&lt;/p&gt;
    &lt;p&gt;Es Adulto: {{ isAdult ? 'Sí' : 'No' }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useUserStore } from './stores/user'

const userStore = useUserStore()

const fullName = userStore.fullName
const isAdult = userStore.isAdult
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_getters_con_parámetros">Getters con Parámetros</h3>
<div class="paragraph">
<p>Los getters en Pinia también pueden aceptar parámetros, lo que permite crear funciones más dinámicas y reutilizables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia'

export const useProductStore = defineStore('product', {
  state: () =&gt; ({
    products: [
      { id: 1, name: 'Product A', price: 100 },
      { id: 2, name: 'Product B', price: 200 },
    ],
  }),
  getters: {
    getProductById: (state) =&gt; {
      return (id: number) =&gt; state.products.find(product =&gt; product.id === id)
    },
  },
})</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_usando_getters_con_parámetros_en_componentes">Usando Getters con Parámetros en Componentes</h3>
<div class="paragraph">
<p>Para usar getters con parámetros en los componentes, simplemente se llama al getter como una función con los argumentos necesarios.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Producto: {{ product.name }} - Precio: {{ product.price }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useProductStore } from './stores/product'

const productStore = useProductStore()
const product = productStore.getProductById(1)
&lt;/script&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_computed_properties_vs_getters">Computed Properties vs Getters</h3>
<div class="paragraph">
<p>Aunque los getters en Pinia son similares a las propiedades computadas en Vue, los getters están diseñados específicamente para trabajar con el estado global del store y pueden ser más eficientes en ciertos casos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia'

export const useCartStore = defineStore('cart', {
  state: () =&gt; ({
    items: [
      { id: 1, name: 'Item A', quantity: 2, price: 50 },
      { id: 2, name: 'Item B', quantity: 1, price: 100 },
    ],
  }),
  getters: {
    totalPrice: (state) =&gt; {
      return state.items.reduce((total, item) =&gt; total + item.quantity * item.price, 0)
    },
  },
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>En resumen, los getters en Pinia son una herramienta poderosa para derivar estado y crear propiedades computadas basadas en el estado del store, proporcionando una forma eficiente y reactiva de manejar el estado global en aplicaciones Vue.</p>
</div>
</div>
<div class="sect2">
<h3 id="_organización_del_estado_global_con_pinia">Organización del estado global con Pinia</h3>
<div class="paragraph">
<p>Pinia permite la creación de un <strong>estado global</strong> en Vue 3 que centraliza el estado de la aplicación, haciendo que este sea accesible desde cualquier componente. La organización de este estado global con Pinia es modular, lo que significa que puedes dividir el estado en múltiples <strong>stores</strong> (stores) según el dominio o la funcionalidad de la aplicación. Esta organización modular mejora la mantenibilidad y escalabilidad del código.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_múltiples_stores">Creación de múltiples stores</h4>
<div class="paragraph">
<p>Cada store en Pinia es independiente y encapsula un conjunto de estado, acciones y getters específicos. A continuación, se muestran ejemplos de cómo organizar el estado en diferentes stores.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Store de Autenticación</strong> (<code>useAuthStore</code>)</p>
</li>
<li>
<p><strong>Store de Productos</strong> (<code>useProductStore</code>)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useAuthStore = defineStore('auth', () =&gt; {
  const user = ref(null);

  function login(userData) {
    user.value = userData;
  }

  function logout() {
    user.value = null;
  }

  const isAuthenticated = computed(() =&gt; user.value !== null);

  return { user, login, logout, isAuthenticated };
});

export const useProductStore = defineStore('product', () =&gt; {
  const products = ref([]);

  function addProduct(product) {
    products.value.push(product);
  }

  function removeProduct(productId) {
    products.value = products.value.filter(p =&gt; p.id !== productId);
  }

  return { products, addProduct, removeProduct };
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>La store <code>useAuthStore</code> gestiona el estado de autenticación (<code>user</code>), así como las funciones <code>login</code> y <code>logout</code>, y un getter <code>isAuthenticated</code> para verificar si el usuario está autenticado.</p>
</li>
<li>
<p>La store <code>useProductStore</code> maneja una lista de productos (<code>products</code>), con funciones para añadir y eliminar productos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_accediendo_al_estado_global_desde_componentes">Accediendo al estado global desde componentes</h4>
<div class="paragraph">
<p>Una vez que se definen las stores, podemos importarlas y usarlas en cualquier componente, accediendo al estado global desde múltiples componentes sin necesidad de pasar <code>props</code> ni emitir eventos.</p>
</div>
<div class="paragraph">
<p>A continuación, se muestra cómo utilizar <code>useAuthStore</code> y <code>useProductStore</code> en un componente <code>Dashboard.vue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Panel de Usuario&lt;/h2&gt;
    &lt;p v-if="auth.isAuthenticated"&gt;Bienvenido, {{ auth.user.name }}&lt;/p&gt;
    &lt;button @click="auth.logout"&gt;Cerrar sesión&lt;/button&gt;

    &lt;h2&gt;Productos&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for="product in products.products" :key="product.id"&gt;
        {{ product.name }}
        &lt;button @click="products.removeProduct(product.id)"&gt;Eliminar&lt;/button&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useAuthStore } from './stores/auth';
import { useProductStore } from './stores/product';

const auth = useAuthStore();
const products = useProductStore();
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- <code>useAuthStore</code> se usa para acceder al estado de autenticación y realizar acciones como <code>logout</code>.
- <code>useProductStore</code> permite listar y manipular productos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_de_carpetas_para_múltiples_stores">Estructura de Carpetas para Múltiples stores</h4>
<div class="paragraph">
<p>Para organizar mejor el estado global en aplicaciones grandes, es conveniente estructurar los archivos de las stores en carpetas. Por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">src/
|-- stores/
|   |-- auth.js
|   |-- product.js</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta estructura modular facilita la administración del estado global, separando cada área funcional en archivos individuales y manteniendo el código limpio.</p>
</div>
</div>
<div class="sect3">
<h4 id="_composición_de_stores">Composición de stores</h4>
<div class="paragraph">
<p>Pinia permite que las stores accedan a otras stores, facilitando la coordinación entre ellas. Supongamos que la store <code>useProductStore</code> necesita información del usuario autenticado (por ejemplo, para limitar la visibilidad de ciertos productos).</p>
</div>
<div class="paragraph">
<p>En <code>useProductStore</code>, podemos importar <code>useAuthStore</code> y utilizarla directamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useAuthStore } from './auth';

export const useProductStore = defineStore('product', () =&gt; {
  const products = ref([]);
  const auth = useAuthStore();

  const visibleProducts = computed(() =&gt; {
    return auth.isAuthenticated ? products.value : [];
  });

  function addProduct(product) {
    products.value.push(product);
  }

  return { products, visibleProducts, addProduct };
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>useAuthStore</code> se usa dentro de <code>useProductStore</code> para verificar el estado de autenticación y, según eso, filtrar los productos visibles.</p>
</li>
<li>
<p><code>visibleProducts</code> es un getter que retorna productos solo si el usuario está autenticado.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_2">Resumen</h4>
<div class="paragraph">
<p>Pinia facilita la organización del estado global en aplicaciones Vue 3 con:
- <strong>Modularidad</strong>: Las stores se organizan en módulos que pueden interactuar de forma independiente o conjunta.
- <strong>Reutilización y Composición</strong>: Las stores pueden usarse en cualquier componente y pueden componer unas a otras para lógica compleja.
- <strong>Estructura Escalable</strong>: La organización de carpetas y el uso de stores independientes permite escalar el estado global fácilmente en aplicaciones grandes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creación_de_stores_y_acceso_desde_componentes">Creación de stores y acceso desde componentes</h3>
<div class="paragraph">
<p>Pinia facilita la gestión de estado global en aplicaciones Vue 3 mediante <strong>stores</strong> (tiendas), que encapsulan el estado y la lógica relacionada en módulos reutilizables. Cada store define el estado, getters y acciones, y se puede acceder a ellos desde cualquier componente, simplificando la comunicación y sincronización de datos en la aplicación.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_un_store_básico">Creación de un store básico</h4>
<div class="paragraph">
<p>Para definir un store, se utiliza <code>defineStore</code>. En este ejemplo, crearemos una tienda de "tareas" (<code>useTaskStore</code>) que manejará el estado de una lista de tareas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia';
import { ref } from 'vue';

export const useTaskStore = defineStore('task', () =&gt; {
  const tasks = ref([{ id: 1, title: 'Aprender Vue 3', completed: false }]);

  function addTask(task) {
    tasks.value.push(task);
  }

  function removeTask(taskId) {
    tasks.value = tasks.value.filter(task =&gt; task.id !== taskId);
  }

  return { tasks, addTask, removeTask };
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>tasks</code> es una lista reactiva de tareas inicializada con un elemento.</p>
</li>
<li>
<p><code>addTask</code> y <code>removeTask</code> son acciones para modificar el estado de la lista de tareas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_accediendo_a_un_store_desde_un_componente">Accediendo a un store desde un componente</h4>
<div class="paragraph">
<p>Para utilizar un store dentro de un componente, simplemente se importa y se instancia, lo cual permite acceder al estado y a las acciones.</p>
</div>
<div class="paragraph">
<p>A continuación, se muestra cómo utilizar el store <code>useTaskStore</code> en un componente <code>TaskList.vue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Lista de Tareas&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for="task in taskStore.tasks" :key="task.id"&gt;
        &lt;span :class="{ completed: task.completed }"&gt;{{ task.title }}&lt;/span&gt;
        &lt;button @click="taskStore.removeTask(task.id)"&gt;Eliminar&lt;/button&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;input v-model="newTask" placeholder="Nueva tarea" /&gt;
    &lt;button @click="addNewTask"&gt;Añadir Tarea&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { ref } from 'vue';
import { useTaskStore } from './stores/task';

const taskStore = useTaskStore();
const newTask = ref('');

function addNewTask() {
  if (newTask.value.trim()) {
    taskStore.addTask({ id: Date.now(), title: newTask.value, completed: false });
    newTask.value = '';
  }
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este componente:
- <code>useTaskStore</code> se instancia como <code>taskStore</code>, permitiendo el acceso al estado y las acciones definidas en el store.
- <code>newTask</code> es una variable local para capturar el valor de la nueva tarea ingresada por el usuario.
- <code>addNewTask</code> llama a <code>addTask</code> en el store para añadir una nueva tarea a la lista.</p>
</div>
</div>
<div class="sect3">
<h4 id="_utilizando_múltiples_stores_en_un_componente">Utilizando múltiples stores en un componente</h4>
<div class="paragraph">
<p>Pinia permite utilizar múltiples stores en un mismo componente, facilitando la administración de diferentes estados de forma modular.</p>
</div>
<div class="paragraph">
<p>Supongamos que además de <code>useTaskStore</code>, queremos utilizar un store de autenticación (<code>useAuthStore</code>) para gestionar el estado del usuario.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Bienvenido, {{ authStore.user.name }}&lt;/h2&gt;
    &lt;button @click="authStore.logout"&gt;Cerrar sesión&lt;/button&gt;
    &lt;h2&gt;Lista de Tareas&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li v-for="task in taskStore.tasks" :key="task.id"&gt;
        &lt;span :class="{ completed: task.completed }"&gt;{{ task.title }}&lt;/span&gt;
        &lt;button @click="taskStore.removeTask(task.id)"&gt;Eliminar&lt;/button&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useTaskStore } from './stores/task';
import { useAuthStore } from './stores/auth';

const taskStore = useTaskStore();
const authStore = useAuthStore();
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>taskStore</code> y <code>authStore</code> son instancias de los stores <code>useTaskStore</code> y <code>useAuthStore</code>, respectivamente.</p>
</li>
<li>
<p>El componente accede a datos tanto de <code>taskStore</code> (lista de tareas) como de <code>authStore</code> (estado de autenticación) y ejecuta acciones relacionadas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_avanzado_getters_y_acciones_asíncronas">Ejemplo avanzado: Getters y acciones asíncronas</h4>
<div class="paragraph">
<p>Además de los estados y acciones básicos, Pinia permite definir <strong>getters</strong> para obtener datos derivados y <strong>acciones asíncronas</strong> para manejar lógica compleja.</p>
</div>
<div class="paragraph">
<p>Aquí se amplía el store <code>useTaskStore</code> con un getter <code>completedTasks</code> para obtener solo las tareas completadas y una acción asíncrona <code>fetchTasks</code> que simula la carga de datos de una API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineStore } from 'pinia';
import { ref, computed } from 'vue';

export const useTaskStore = defineStore('task', () =&gt; {
  const tasks = ref([]);

  const completedTasks = computed(() =&gt; tasks.value.filter(task =&gt; task.completed));

  async function fetchTasks() {
    // Simulación de una llamada asíncrona a una API
    const fetchedTasks = await new Promise(resolve =&gt;
      setTimeout(() =&gt; resolve([{ id: 1, title: 'Estudiar Vue 3', completed: false }]), 1000)
    );
    tasks.value = fetchedTasks;
  }

  function addTask(task) {
    tasks.value.push(task);
  }

  return { tasks, completedTasks, fetchTasks, addTask };
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>completedTasks</code> es un getter que filtra las tareas completadas y reacciona a los cambios en <code>tasks</code>.</p>
</li>
<li>
<p><code>fetchTasks</code> es una acción asíncrona que simula la carga de datos desde una API, asignando el resultado a <code>tasks</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_3">Resumen</h4>
<div class="paragraph">
<p>Pinia permite definir stores modulares con estados, getters y acciones que facilitan la gestión y sincronización de datos entre componentes. Acceder a estos stores desde los componentes es sencillo y permite compartir estados de manera centralizada, logrando una arquitectura limpia y escalable en aplicaciones Vue 3.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mejores_prácticas_de_uso_de_pinia_en_aplicaciones_vue_3">Mejores prácticas de uso de Pinia en aplicaciones Vue 3</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Modularización:</strong> Organizar los stores en módulos para mantener el código limpio y manejable. Cada módulo puede representar una parte de la aplicación (e.g., usuario, productos, etc.).</p>
</li>
<li>
<p><strong>Uso de TypeScript:</strong> Definir tipos para los estados, acciones y getters para mejorar la claridad y la detección de errores en tiempo de compilación.</p>
</li>
<li>
<p><strong>Persistencia del estado:</strong> Utilizar plugins de persistencia si es necesario mantener el estado entre sesiones del navegador.</p>
</li>
<li>
<p><strong>Acceso controlado al estado:</strong> Limitar el acceso directo al estado, utilizando acciones para cualquier modificación, lo que ayuda a mantener la integridad del estado.</p>
</li>
<li>
<p><strong>Pruebas:</strong> Implementar pruebas unitarias para los stores, asegurando que las acciones y los getters funcionan como se espera.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_5_rutado_con_vue_router_4">Módulo 5: Rutado con Vue Router 4</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_configuración_de_vue_router_4_en_vue_3">Configuración de Vue Router 4 en Vue 3</h3>
<div class="paragraph">
<p>Vue Router 4 es la versión oficial del enrutador para Vue 3 y permite agregar navegación entre componentes y vistas en una aplicación de una sola página (SPA). Configurar Vue Router es sencillo y proporciona un sistema flexible para gestionar rutas y parámetros.</p>
</div>
<div class="sect3">
<h4 id="_instalación_de_vue_router">Instalación de Vue Router</h4>
<div class="paragraph">
<p>Si Vue Router no está instalado, puedes agregarlo a tu proyecto con el siguiente comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">npm install vue-router</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_básica_de_vue_router">Configuración básica de Vue Router</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Definir Rutas</strong>: Las rutas se configuran en un archivo dedicado, típicamente <code>src/router/index.js</code> o <code>src/router/index.ts</code>, dependiendo de si usas JavaScript o TypeScript.</p>
</li>
<li>
<p><strong>Crear la Instancia de Router</strong>: Se crea una instancia de <code>createRouter</code> y se le pasa la configuración de rutas.</p>
</li>
<li>
<p><strong>Integrar el Router en Vue</strong>: La instancia de router se pasa a la aplicación Vue para habilitar el enrutamiento.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { createRouter, createWebHistory } from 'vue-router';
import HomeView from '../views/HomeView.vue';
import AboutView from '../views/AboutView.vue';

const routes = [
  { path: '/', name: 'Home', component: HomeView },
  { path: '/about', name: 'About', component: AboutView },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

export default router;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>createWebHistory()</code> permite utilizar el modo de historial de HTML5, generando rutas limpias sin el <code>#</code>.</p>
</li>
<li>
<p><code>routes</code> es un array de objetos de ruta, donde cada objeto define <code>path</code>, <code>name</code> (opcional) y <code>component</code> para una vista.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_integración_de_vue_router_con_la_aplicación_vue">Integración de Vue Router con la aplicación Vue</h4>
<div class="paragraph">
<p>Una vez configurado el router, se debe integrarlo en la instancia principal de la aplicación en <code>main.js</code> o <code>main.ts</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { createApp } from 'vue';
import App from './App.vue';
import router from './router';

const app = createApp(App);

app.use(router);
app.mount('#app');</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este paso:
- <code>app.use(router)</code> agrega Vue Router a la aplicación Vue.</p>
</div>
</div>
<div class="sect3">
<h4 id="_navegación_entre_vistas">Navegación entre vistas</h4>
<div class="paragraph">
<p>Para navegar entre diferentes vistas, se puede utilizar el componente <code>&lt;router-link&gt;</code>, o programáticamente mediante <code>$router</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Mi Aplicación&lt;/h1&gt;
    &lt;nav&gt;
      &lt;router-link to="/"&gt;Inicio&lt;/router-link&gt;
      &lt;router-link to="/about"&gt;Acerca de&lt;/router-link&gt;
    &lt;/nav&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;router-link&gt;</code> crea enlaces que se sincronizan automáticamente con el router.</p>
</li>
<li>
<p><code>&lt;router-view&gt;</code> es un espacio reservado para mostrar el componente de la ruta actual.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_rutas_dinámicas_con_parámetros">Rutas dinámicas con parámetros</h4>
<div class="paragraph">
<p>Vue Router permite definir rutas dinámicas usando parámetros (<code>:param</code>) para manejar URLs dinámicas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">const routes = [
  { path: '/user/:id', name: 'UserProfile', component: UserProfile },
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dentro del componente <code>UserProfile</code>, se puede acceder al parámetro <code>id</code> usando <code>$route.params</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h2&gt;Perfil del Usuario&lt;/h2&gt;
    &lt;p&gt;ID de Usuario: {{ $route.params.id }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto permite acceder al <code>id</code> dinámico para cargar datos específicos del usuario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rutas_anidadas">Rutas anidadas</h4>
<div class="paragraph">
<p>Las rutas anidadas permiten definir subrutas dentro de una ruta principal. Esto es útil para diseñar vistas con contenido jerárquico.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const routes = [
  {
    path: '/user/:id',
    component: UserProfile,
    children: [
      { path: 'posts', component: UserPosts },
      { path: 'settings', component: UserSettings },
    ],
  },
];</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>La ruta <code>/user/:id/posts</code> mostrará el componente <code>UserPosts</code> como una subvista de <code>UserProfile</code>.</p>
</li>
<li>
<p><code>&lt;router-view&gt;</code> dentro de <code>UserProfile</code> cargará el componente de la subruta actual.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_navegación_programática">Navegación programática</h4>
<div class="paragraph">
<p>También se puede navegar entre rutas de manera programática mediante <code>$router.push</code> o <code>$router.replace</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;button @click="goToAbout"&gt;Ir a Acerca de&lt;/button&gt;
&lt;/template&gt;

&lt;script lang="ts" setup&gt;
import { useRouter } from 'vue-router';

const router = useRouter();

function goToAbout() {
  router.push({ name: 'About' });
}
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>router.push({ name: 'About' })</code> navega a la ruta nombrada "About".</p>
</li>
<li>
<p><code>router.replace</code> funciona de forma similar, pero reemplaza la entrada actual en el historial de navegación.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_de_rutas_no_encontradas_404">Manejo de rutas no encontradas (404)</h4>
<div class="paragraph">
<p>Para capturar rutas no definidas, se puede agregar una ruta de "catch-all" al final de la lista de rutas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">const routes = [
  // otras rutas
  { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFoundView },
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esta ruta mostrará <code>NotFoundView</code> para cualquier URL que no coincida con las rutas definidas previamente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_4">Resumen</h4>
<div class="paragraph">
<p>Vue Router 4 permite:
- <strong>Definir rutas</strong> simples, dinámicas y anidadas.
- <strong>Navegación</strong> entre rutas mediante <code>&lt;router-link&gt;</code> o <code>$router</code>.
- <strong>Gestión de parámetros</strong> en rutas dinámicas.
- <strong>Manejo de rutas no encontradas</strong>, configurando una ruta "catch-all".</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_protegiendo_rutas_con_guardias_de_navegación">Protegiendo rutas con guardias de navegación</h3>
<div class="paragraph">
<p>Los guardias de navegación en Vue Router permiten controlar el acceso a rutas y realizar acciones antes de la navegación. Esto es útil para implementar autenticación, permisos y otras validaciones antes de que un usuario pueda acceder a una vista específica.</p>
</div>
<div class="paragraph">
<p>Vue Router ofrece varios tipos de guardias de navegación:
1. <strong>Guardias globales</strong>: se ejecutan para todas las rutas.
2. <strong>Guardias específicos de ruta</strong>: se configuran directamente en la definición de la ruta.
3. <strong>Guardias de componente</strong>: se definen dentro de los componentes que requieren protección.</p>
</div>
<div class="sect3">
<h4 id="_guardias_de_navegación_globales">Guardias de navegación globales</h4>
<div class="paragraph">
<p>Los guardias globales permiten aplicar verificaciones antes, durante o después de cualquier navegación. Para definirlos, se usa <code>router.beforeEach</code>, <code>router.beforeResolve</code>, o <code>router.afterEach</code>.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de <code>beforeEach</code> para verificar autenticación en todas las rutas:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { createRouter, createWebHistory } from 'vue-router';
import HomeView from '../views/HomeView.vue';
import LoginView from '../views/LoginView.vue';
import { useAuthStore } from '../stores/auth';

const routes = [
  { path: '/', name: 'Home', component: HomeView },
  { path: '/login', name: 'Login', component: LoginView },
  { path: '/dashboard', name: 'Dashboard', component: () =&gt; import('../views/DashboardView.vue'), meta: { requiresAuth: true } },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Guardián global de autenticación
router.beforeEach((to, from, next) =&gt; {
  const authStore = useAuthStore();

  if (to.meta.requiresAuth &amp;&amp; !authStore.isAuthenticated) {
    next({ name: 'Login' });
  } else {
    next();
  }
});

export default router;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>router.beforeEach</code> verifica si la ruta de destino (<code>to</code>) tiene la propiedad <code>meta.requiresAuth</code>.</p>
</li>
<li>
<p>Si <code>requiresAuth</code> es <code>true</code> y el usuario no está autenticado, redirige a la vista de <code>Login</code>.</p>
</li>
<li>
<p>De lo contrario, permite la navegación (<code>next()</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_guardias_específicos_de_ruta">Guardias específicos de ruta</h4>
<div class="paragraph">
<p>Los guardias específicos de ruta se pueden definir en la configuración de cada ruta mediante <code>beforeEnter</code>. Este tipo de guardias es útil para proteger rutas individuales sin afectar a las demás.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const routes = [
  { path: '/', name: 'Home', component: HomeView },
  {
    path: '/admin',
    name: 'Admin',
    component: () =&gt; import('../views/AdminView.vue'),
    beforeEnter: (to, from, next) =&gt; {
      const authStore = useAuthStore();
      if (authStore.isAdmin) {
        next();
      } else {
        next({ name: 'Home' });
      }
    },
  },
];</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>La ruta <code>/admin</code> usa <code>beforeEnter</code> para verificar si el usuario tiene privilegios de administrador (<code>isAdmin</code>).</p>
</li>
<li>
<p>Si el usuario no es administrador, redirige a la vista <code>Home</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_guardias_de_navegación_dentro_de_componentes">Guardias de navegación dentro de componentes</h4>
<div class="paragraph">
<p>Los componentes individuales también pueden implementar guardias de navegación a través de los hooks <code>beforeRouteEnter</code>, <code>beforeRouteUpdate</code> y <code>beforeRouteLeave</code>.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo: Validación dentro de un componente <code>ProfileView.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Perfil de Usuario&lt;/h1&gt;
    &lt;p&gt;Bienvenido, {{ userName }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';

export default defineComponent({
  name: 'ProfileView',
  data() {
    return {
      userName: 'Usuario',
    };
  },
  beforeRouteEnter(to, from, next) {
    // Verificación antes de ingresar a la ruta
    const isAuthenticated = false; // Cambiar según el estado de autenticación
    if (isAuthenticated) {
      next();
    } else {
      next({ name: 'Login' });
    }
  },
  beforeRouteLeave(to, from, next) {
    // Confirmar si se desea salir de la página
    const answer = window.confirm('¿Seguro que deseas abandonar la página?');
    if (answer) {
      next();
    } else {
      next(false); // Cancelar la navegación
    }
  },
});
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>beforeRouteEnter</code> verifica si el usuario está autenticado antes de mostrar <code>ProfileView</code>. Si no, redirige a <code>Login</code>.</p>
</li>
<li>
<p><code>beforeRouteLeave</code> muestra una confirmación antes de permitir que el usuario abandone la vista.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_meta_campos_para_roles_y_permisos">Uso de meta campos para roles y permisos</h4>
<div class="paragraph">
<p>Los meta campos en las rutas permiten establecer permisos específicos que luego se validan en los guardias de navegación.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de configuración de roles en rutas:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">const routes = [
  { path: '/', name: 'Home', component: HomeView },
  { path: '/user', name: 'UserDashboard', component: UserDashboardView, meta: { role: 'user' } },
  { path: '/admin', name: 'AdminDashboard', component: AdminDashboardView, meta: { role: 'admin' } },
];

router.beforeEach((to, from, next) =&gt; {
  const authStore = useAuthStore();
  if (to.meta.role &amp;&amp; to.meta.role !== authStore.userRole) {
    next({ name: 'Home' });
  } else {
    next();
  }
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>to.meta.role</code> especifica el rol requerido para acceder a cada ruta.</p>
</li>
<li>
<p>El guardia global verifica que el rol del usuario (<code>authStore.userRole</code>) coincida con el rol requerido por la ruta. Si no coincide, redirige a la vista <code>Home</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_5">Resumen</h4>
<div class="paragraph">
<p>Los guardias de navegación en Vue Router permiten implementar de manera eficaz el control de acceso en las rutas:
- <strong>Guardias globales</strong>: Protegen todas las rutas y se configuran en el router principal.
- <strong>Guardias específicos de ruta</strong>: Definen protección individual para una ruta específica.
- <strong>Guardias de componente</strong>: Permiten verificaciones y confirmaciones dentro de un componente en particular.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_6_api_de_composición_avanzada">Módulo 6: API de Composición Avanzada</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_uso_avanzado_de_reactive_torefs_y_toref">Uso avanzado de <code>reactive</code>, <code>toRefs</code> y <code>toRef</code></h3>
<div class="paragraph">
<p>En Vue 3, <code>reactive</code>, <code>toRefs</code> y <code>toRef</code> permiten crear y gestionar objetos y propiedades reactivas de manera avanzada, ofreciendo un control preciso sobre el comportamiento de la reactividad en componentes.</p>
</div>
<div class="sect3">
<h4 id="_reactive"><code>reactive</code></h4>
<div class="paragraph">
<p><code>reactive</code> convierte un objeto en reactivo, detectando y propagando automáticamente los cambios en cualquier propiedad del objeto.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { reactive } from 'vue';

const state = reactive({
  user: {
    name: 'Juan',
    age: 25,
  },
  loggedIn: false,
});

state.user.name = 'Carlos'; // Actualiza reactivamente
state.loggedIn = true;      // También reactivo</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, cualquier cambio en <code>state.user.name</code> o <code>state.loggedIn</code> actualizará automáticamente cualquier parte de la UI que dependa de esos datos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_torefs"><code>toRefs</code></h4>
<div class="paragraph">
<p><code>toRefs</code> permite desestructurar un objeto reactivo manteniendo la reactividad de cada propiedad individual, útil al retornar datos de <code>reactive</code> en la función <code>setup</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { reactive, toRefs } from 'vue';

export default {
  setup() {
    const state = reactive({
      user: {
        name: 'Ana',
        age: 30,
      },
      loggedIn: true,
    });

    return { ...toRefs(state) };
  },
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>toRefs(state)</code> convierte cada propiedad de <code>state</code> en una referencia (<code>ref</code>), manteniendo la reactividad.</p>
</li>
<li>
<p>Las propiedades de <code>state</code> (<code>user</code>, <code>loggedIn</code>) pueden usarse de manera reactiva en la plantilla.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_toref"><code>toRef</code></h4>
<div class="paragraph">
<p><code>toRef</code> crea una referencia reactiva para una sola propiedad específica de un objeto reactivo. Es útil cuando solo se necesita la reactividad de una propiedad en particular.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { reactive, toRef } from 'vue';

export default {
  setup() {
    const state = reactive({
      user: {
        name: 'Pedro',
        age: 40,
      },
    });

    const userNameRef = toRef(state.user, 'name');

    function updateName(newName) {
      userNameRef.value = newName;
    }

    return { userNameRef, updateName };
  },
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>toRef(state.user, 'name')</code> crea una referencia reactiva <code>userNameRef</code> solo para <code>name</code>.</p>
</li>
<li>
<p><code>updateName</code> permite actualizar <code>name</code> de forma reactiva.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_combinación_de_reactive_torefs_y_toref">Combinación de <code>reactive</code>, <code>toRefs</code> y <code>toRef</code></h4>
<div class="paragraph">
<p>A veces, es útil combinar estas funcionalidades para acceder y actualizar de manera reactiva tanto al objeto completo como a propiedades individuales.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { reactive, toRefs, toRef } from 'vue';

export default {
  setup() {
    const state = reactive({
      user: {
        name: 'Luisa',
        age: 22,
        location: 'Madrid',
      },
      loggedIn: false,
    });

    const { user, loggedIn } = toRefs(state);
    const userLocation = toRef(state.user, 'location');

    function updateLocation(newLocation) {
      userLocation.value = newLocation;
    }

    return { user, loggedIn, userLocation, updateLocation };
  },
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>toRefs(state)</code> convierte <code>user</code> y <code>loggedIn</code> en referencias, manteniendo su reactividad.</p>
</li>
<li>
<p><code>toRef(state.user, 'location')</code> crea una referencia reactiva a la propiedad <code>location</code>.</p>
</li>
<li>
<p><code>updateLocation</code> permite actualizar <code>location</code> sin afectar otras propiedades de <code>user</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_al_usar_torefs_y_toref">Consideraciones al usar <code>toRefs</code> y <code>toRef</code></h4>
<div class="ulist">
<ul>
<li>
<p><strong><code>toRefs</code> es ideal</strong> cuando necesitas desestructurar el estado completo pero mantener la reactividad en cada propiedad.</p>
</li>
<li>
<p><strong><code>toRef</code> es útil</strong> para observar una sola propiedad, permitiendo optimizar la reactividad y reducir dependencias.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_6">Resumen</h4>
<div class="paragraph">
<p><code>reactive</code>, <code>toRefs</code> y <code>toRef</code> son herramientas poderosas para:
- Convertir objetos y propiedades en reactivos con <code>reactive</code>.
- Mantener la reactividad al desestructurar objetos con <code>toRefs</code>.
- Gestionar propiedades específicas de forma reactiva con <code>toRef</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_provide_y_inject_para_dependencias"><code>provide</code> y <code>inject</code> para dependencias</h3>
<div class="paragraph">
<p>En Vue 3, <code>provide</code> e <code>inject</code> permiten compartir datos o funciones entre componentes sin necesidad de pasarlos explícitamente a través de <code>props</code>. Esta técnica facilita la comunicación entre componentes jerárquicamente distantes y es ideal para manejar dependencias de manera centralizada.</p>
</div>
<div class="sect3">
<h4 id="_uso_de_provide_para_compartir_datos_desde_un_componente_padre">Uso de <code>provide</code> para compartir datos desde un componente padre</h4>
<div class="paragraph">
<p><code>provide</code> se usa en el componente padre para "proveer" datos o funciones a componentes hijos. Cualquier componente descendiente puede entonces "inyectar" estos datos usando <code>inject</code>.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo básico de <code>provide</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineComponent, reactive, provide } from 'vue';

export default defineComponent({
  name: 'ParentComponent',
  setup() {
    const userData = reactive({
      name: 'Carlos',
      age: 28,
    });

    provide('userData', userData);

    return {};
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Componente Padre&lt;/h2&gt;
      &lt;ChildComponent /&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>provide('userData', userData)</code> permite que el objeto <code>userData</code> esté disponible para los componentes hijos.</p>
</li>
<li>
<p>El string <code>'userData'</code> actúa como clave que los componentes hijos usarán para "inyectar" el dato.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_inject_para_consumir_datos_en_un_componente_hijo">Uso de <code>inject</code> para consumir datos en un componente hijo</h4>
<div class="paragraph">
<p><code>inject</code> permite acceder a los datos proporcionados por <code>provide</code> en un componente hijo. Es útil para recibir y usar estos datos sin necesidad de pasar <code>props</code>.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo básico de <code>inject</code> en el componente hijo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineComponent, inject } from 'vue';

export default defineComponent({
  name: 'ChildComponent',
  setup() {
    const userData = inject('userData');

    return { userData };
  },
  template: `
    &lt;div&gt;
      &lt;h3&gt;Componente Hijo&lt;/h3&gt;
      &lt;p&gt;Nombre: {{ userData?.name }}&lt;/p&gt;
      &lt;p&gt;Edad: {{ userData?.age }}&lt;/p&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>inject('userData')</code> permite al componente hijo acceder a <code>userData</code> usando la clave <code>'userData'</code>.</p>
</li>
<li>
<p>Los valores de <code>userData</code> se pueden mostrar en el template del componente hijo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_proveer_funciones_como_dependencias">Proveer funciones como dependencias</h4>
<div class="paragraph">
<p>No solo datos, sino también funciones pueden compartirse usando <code>provide</code> e <code>inject</code>, lo que permite que los componentes hijos realicen acciones definidas en el componente padre.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineComponent, provide } from 'vue';

export default defineComponent({
  name: 'ParentComponentWithFunction',
  setup() {
    const logMessage = (message: string) =&gt; {
      console.log(`Mensaje desde el componente padre: ${message}`);
    };

    provide('logMessage', logMessage);

    return {};
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Componente Padre con Función&lt;/h2&gt;
      &lt;ChildComponentWithFunction /&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el componente hijo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineComponent, inject } from 'vue';

export default defineComponent({
  name: 'ChildComponentWithFunction',
  setup() {
    const logMessage = inject('logMessage') as (message: string) =&gt; void;

    const handleClick = () =&gt; {
      logMessage?.('Hola desde el componente hijo');
    };

    return { handleClick };
  },
  template: `
    &lt;div&gt;
      &lt;h3&gt;Componente Hijo&lt;/h3&gt;
      &lt;button @click="handleClick"&gt;Enviar Mensaje&lt;/button&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>provide('logMessage', logMessage)</code> comparte la función <code>logMessage</code> con los componentes hijos.</p>
</li>
<li>
<p><code>inject('logMessage')</code> permite al hijo acceder y ejecutar <code>logMessage</code> cuando se hace clic en el botón.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_valores_predeterminados_con_inject">Valores predeterminados con <code>inject</code></h4>
<div class="paragraph">
<p>Si un valor no está disponible en <code>provide</code>, <code>inject</code> puede aceptar un segundo argumento para establecer un valor predeterminado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">const userName = inject('userName', 'Usuario Anónimo');</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Si <code>userName</code> no se proporciona desde un componente padre, <code>inject</code> devolverá <code>'Usuario Anónimo'</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_provide_e_inject_reactivos_con_ref_o_reactive"><code>provide</code> e <code>inject</code> reactivos con <code>ref</code> o <code>reactive</code></h4>
<div class="paragraph">
<p>Cuando se usa <code>provide</code> para datos reactivos, los componentes hijos reciben automáticamente actualizaciones al cambiar el valor proporcionado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-typescript hljs" data-lang="typescript">import { defineComponent, reactive, provide } from 'vue';

export default defineComponent({
  name: 'ReactiveParent',
  setup() {
    const sharedState = reactive({ count: 0 });

    provide('sharedState', sharedState);

    const increment = () =&gt; {
      sharedState.count++;
    };

    return { increment };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Componente Padre Reactivo&lt;/h2&gt;
      &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
      &lt;ChildComponentReactive /&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el componente hijo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, inject } from 'vue';

export default defineComponent({
  name: 'ChildComponentReactive',
  setup() {
    const sharedState = inject('sharedState');

    return { sharedState };
  },
  template: `
    &lt;div&gt;
      &lt;h3&gt;Componente Hijo Reactivo&lt;/h3&gt;
      &lt;p&gt;Contador compartido: {{ sharedState?.count }}&lt;/p&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>sharedState.count</code> se actualiza en tiempo real en el componente hijo cuando el botón en el componente padre incrementa el valor.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_7">Resumen</h4>
<div class="ulist">
<div class="title"><code>provide</code> e <code>inject</code> permiten:</div>
<ul>
<li>
<p>Compartir datos y funciones entre componentes padre e hijo sin <code>props</code>.</p>
</li>
<li>
<p>Gestionar dependencias de forma centralizada.</p>
</li>
<li>
<p>Crear aplicaciones más escalables y modularizadas al simplificar la estructura de datos compartidos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uso_de_watch_y_watcheffect_para_observación_reactiva">Uso de <code>watch</code> y <code>watchEffect</code> para observación reactiva</h3>
<div class="paragraph">
<p>Vue 3 ofrece <code>watch</code> y <code>watchEffect</code> para observar y reaccionar a los cambios en datos reactivos. <code>watch</code> permite observar propiedades específicas, mientras que <code>watchEffect</code> se ejecuta de inmediato y rastrea automáticamente las dependencias reactivas usadas dentro de su función.</p>
</div>
<div class="sect3">
<h4 id="_watch_observando_propiedades_específicas"><code>watch</code>: Observando propiedades específicas</h4>
<div class="paragraph">
<p><code>watch</code> se usa para observar cambios en propiedades específicas y ejecutar funciones cuando cambian. Esto es útil cuando se requiere una respuesta a cambios en datos particulares sin afectar otros elementos reactivos.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo básico de <code>watch</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref, watch } from 'vue';

export default {
  setup() {
    const count = ref(0);

    watch(count, (newValue, oldValue) =&gt; {
      console.log(`El valor de count cambió de ${oldValue} a ${newValue}`);
    });

    const increment = () =&gt; count.value++;

    return { count, increment };
  },
  template: `
    &lt;div&gt;
      &lt;p&gt;Count: {{ count }}&lt;/p&gt;
      &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
    &lt;/div&gt;
  `,
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>watch(count, callback)</code> observa la referencia <code>count</code>.</p>
</li>
<li>
<p>La función de <code>callback</code> se ejecuta cada vez que <code>count</code> cambia, mostrando el valor anterior y el nuevo en la consola.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_observación_de_propiedades_dentro_de_objetos_reactivos">Observación de propiedades dentro de objetos reactivos</h4>
<div class="paragraph">
<p>Cuando se observan propiedades dentro de un objeto reactivo, se debe proporcionar una función que acceda a esa propiedad específica.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo: Observación de propiedades anidadas:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { reactive, watch } from 'vue';

export default {
  setup() {
    const user = reactive({
      name: 'Ana',
      age: 30,
    });

    watch(
      () =&gt; user.age,
      (newAge, oldAge) =&gt; {
        console.log(`La edad cambió de ${oldAge} a ${newAge}`);
      }
    );

    const incrementAge = () =&gt; user.age++;

    return { user, incrementAge };
  },
  template: `
    &lt;div&gt;
      &lt;p&gt;Edad: {{ user.age }}&lt;/p&gt;
      &lt;button @click="incrementAge"&gt;Incrementar Edad&lt;/button&gt;
    &lt;/div&gt;
  `,
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>La función <code>() &#8658; user.age</code> permite observar solo la propiedad <code>age</code> dentro de <code>user</code>, reaccionando a cambios en esa propiedad específica.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_watcheffect_observación_automática_de_dependencias"><code>watchEffect</code>: Observación automática de dependencias</h4>
<div class="paragraph">
<p><code>watchEffect</code> rastrea automáticamente todas las dependencias reactivas utilizadas en su función, lo que permite observar múltiples dependencias sin declararlas explícitamente. Se ejecuta inmediatamente al inicio y luego cada vez que cambian las dependencias.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo básico de <code>watchEffect</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref, watchEffect } from 'vue';

export default {
  setup() {
    const count = ref(0);
    const doubleCount = ref(0);

    watchEffect(() =&gt; {
      doubleCount.value = count.value * 2;
      console.log(`doubleCount ahora es ${doubleCount.value}`);
    });

    const increment = () =&gt; count.value++;

    return { count, doubleCount, increment };
  },
  template: `
    &lt;div&gt;
      &lt;p&gt;Count: {{ count }}&lt;/p&gt;
      &lt;p&gt;doubleCount: {{ doubleCount }}&lt;/p&gt;
      &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
    &lt;/div&gt;
  `,
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>watchEffect</code> rastrea automáticamente <code>count</code> y recalcula <code>doubleCount</code> cada vez que cambia <code>count</code>.</p>
</li>
<li>
<p><code>doubleCount</code> se actualiza y se muestra en la consola sin necesidad de configurar explícitamente una dependencia en <code>watch</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_diferencias_clave_entre_watch_y_watcheffect">Diferencias clave entre <code>watch</code> y <code>watchEffect</code></h4>
<div class="ulist">
<ul>
<li>
<p><strong><code>watch</code></strong>: Es adecuado cuando se requiere observar propiedades o valores específicos. Su función de callback se ejecuta solo cuando cambian los valores observados.</p>
</li>
<li>
<p><strong><code>watchEffect</code></strong>: Es ideal para tareas reactivas generales que requieren rastrear múltiples dependencias de manera implícita. Su función se ejecuta inmediatamente y en cada cambio de cualquier dependencia utilizada dentro de su cuerpo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_combinado_de_watch_y_watcheffect">Ejemplo combinado de <code>watch</code> y <code>watchEffect</code></h4>
<div class="paragraph">
<p>Un caso común es usar ambos cuando se requiere observar propiedades específicas y calcular otros valores derivados de manera reactiva.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref, reactive, watch, watchEffect } from 'vue';

export default {
  setup() {
    const user = reactive({
      name: 'Carlos',
      age: 25,
    });
    const status = ref('inactivo');

    // Observa cambios en la edad del usuario
    watch(
      () =&gt; user.age,
      (newAge) =&gt; {
        status.value = newAge &gt;= 18 ? 'adulto' : 'menor';
      }
    );

    // Calcula mensaje reactivo basado en el estado
    watchEffect(() =&gt; {
      console.log(`Usuario: ${user.name}, Estado: ${status.value}`);
    });

    const incrementAge = () =&gt; user.age++;

    return { user, status, incrementAge };
  },
  template: `
    &lt;div&gt;
      &lt;p&gt;Nombre: {{ user.name }}&lt;/p&gt;
      &lt;p&gt;Edad: {{ user.age }}&lt;/p&gt;
      &lt;p&gt;Estado: {{ status }}&lt;/p&gt;
      &lt;button @click="incrementAge"&gt;Incrementar Edad&lt;/button&gt;
    &lt;/div&gt;
  `,
};</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>watch</code> actualiza <code>status</code> en función de la edad del usuario.</p>
</li>
<li>
<p><code>watchEffect</code> muestra en la consola un mensaje reactivo cada vez que cambian <code>user.name</code> o <code>status</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_8">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p><strong><code>watch</code></strong> permite observar y reaccionar a propiedades específicas o valores individuales.</p>
</li>
<li>
<p><strong><code>watchEffect</code></strong> permite rastrear automáticamente todas las dependencias reactivas dentro de su función.</p>
</li>
<li>
<p><strong>Ambos</strong> son útiles para gestionar la reactividad avanzada, simplificando la sincronización y actualización de valores en componentes Vue 3.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creación_de_composables_personalizados">Creación de composables personalizados</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Definición de composables:</strong> Los composables son funciones que encapsulan lógica reutilizable. Utilizan la API de Composición para gestionar el estado y comportamientos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { ref } from 'vue';

  export function useCounter() {
      const count = ref(0);
      const increment = () =&gt; count.value++;
      const decrement = () =&gt; count.value--;
      return { count, increment, decrement };
  }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Uso de un composable en un componente:</strong></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { useCounter } from '@/composables/useCounter';

  setup() {
      const { count, increment, decrement } = useCounter();
      return { count, increment, decrement };
  }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimización_y_reutilización_de_lógica_con_composables">Optimización y reutilización de lógica con composables</h3>
<div class="paragraph">
<p>Los composables son funciones reutilizables en Vue 3 que encapsulan y comparten lógica reactiva entre componentes. Permiten separar la lógica de negocio o comportamiento de la estructura visual, lo que hace el código más modular, mantenible y escalable.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_un_composable_básico">Creación de un composable básico</h4>
<div class="paragraph">
<p>Para crear un composable, simplemente define una función que encapsule lógica reactiva usando la Composition API y retorna los valores o métodos que deben estar disponibles para el componente que lo utiliza.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo básico de un composable para manejar un contador:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref } from 'vue';

export function useCounter() {
  const count = ref(0);

  const increment = () =&gt; count.value++;
  const decrement = () =&gt; count.value--;

  return { count, increment, decrement };
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>useCounter</code> encapsula la lógica de un contador con <code>ref</code> para <code>count</code> y métodos <code>increment</code> y <code>decrement</code>.</p>
</li>
<li>
<p><code>count</code>, <code>increment</code>, y <code>decrement</code> se exportan y pueden reutilizarse en cualquier componente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_usando_un_composable_en_un_componente_2">Usando un composable en un componente</h4>
<div class="paragraph">
<p>Para utilizar el composable, importa la función y llámala dentro del <code>setup()</code> del componente. Esto permite acceder a la lógica encapsulada.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent } from 'vue';
import { useCounter } from './composables/useCounter';

export default defineComponent({
  setup() {
    const { count, increment, decrement } = useCounter();

    return { count, increment, decrement };
  },
  template: `
    &lt;div&gt;
      &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
      &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
      &lt;button @click="decrement"&gt;Decrementar&lt;/button&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este componente:</div>
<ul>
<li>
<p><code>useCounter</code> proporciona los métodos y variables necesarias para manejar el contador.</p>
</li>
<li>
<p><code>increment</code> y <code>decrement</code> controlan las acciones y <code>count</code> refleja el valor actual en la interfaz.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_composables_con_datos_reactivos_y_watch">Composables con datos reactivos y <code>watch</code></h4>
<div class="paragraph">
<p>Un composable puede contener datos reactivos complejos y lógica de observación usando <code>reactive</code> y <code>watch</code>. Esto es útil para tareas como manejar el estado de formularios o almacenar información de usuarios.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de un composable de formulario con validación:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { reactive, ref, watch } from 'vue';

export function useForm() {
  const form = reactive({
    name: '',
    email: '',
  });
  const errors = ref([]);

  watch(
    () =&gt; form.email,
    (newEmail) =&gt; {
      errors.value = [];
      if (!newEmail.includes('@')) {
        errors.value.push('El correo debe contener un "@"');
      }
    }
  );

  const submitForm = () =&gt; {
    if (errors.value.length === 0) {
      console.log('Formulario enviado:', form);
    } else {
      console.log('Errores en el formulario:', errors.value);
    }
  };

  return { form, errors, submitForm };
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>useForm</code> encapsula un formulario reactivo y realiza validación sobre el campo de correo.</p>
</li>
<li>
<p><code>watch</code> revisa cambios en el correo y actualiza los errores en tiempo real.</p>
</li>
<li>
<p><code>submitForm</code> actúa como un método para enviar el formulario si no hay errores.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reutilización_avanzada_con_parámetros_en_composables">Reutilización avanzada con parámetros en composables</h4>
<div class="paragraph">
<p>Los composables pueden aceptar parámetros para personalizar su funcionalidad, permitiendo una reutilización más flexible.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo: Composable de contador con paso de incremento personalizado:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref } from 'vue';

export function useCounter(step = 1) {
  const count = ref(0);

  const increment = () =&gt; count.value += step;
  const decrement = () =&gt; count.value -= step;

  return { count, increment, decrement };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este composable permite definir un valor de incremento o decremento personalizado cada vez que se usa <code>useCounter</code>.</p>
</div>
<div class="paragraph">
<p><strong>Uso en un componente:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent } from 'vue';
import { useCounter } from './composables/useCounter';

export default defineComponent({
  setup() {
    const { count, increment, decrement } = useCounter(5); // Paso personalizado de 5

    return { count, increment, decrement };
  },
  template: `
    &lt;div&gt;
      &lt;p&gt;Contador: {{ count }}&lt;/p&gt;
      &lt;button @click="increment"&gt;Incrementar por 5&lt;/button&gt;
      &lt;button @click="decrement"&gt;Decrementar por 5&lt;/button&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>useCounter(5)</code> establece un paso de 5 para el contador.</p>
</li>
<li>
<p>El componente puede ajustar dinámicamente el comportamiento del contador según sus necesidades.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_composables_con_provide_e_inject_para_dependencia_global">Composables con <code>provide</code> e <code>inject</code> para dependencia global</h4>
<div class="paragraph">
<p>Los composables también pueden usar <code>provide</code> e <code>inject</code> para compartir lógica reactiva global, como un tema o un estado de autenticación.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de un composable para un tema global:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { ref, provide, inject } from 'vue';

const ThemeSymbol = Symbol('theme');

export function provideTheme() {
  const theme = ref('light');

  const toggleTheme = () =&gt; {
    theme.value = theme.value === 'light' ? 'dark' : 'light';
  };

  provide(ThemeSymbol, { theme, toggleTheme });
}

export function useTheme() {
  const themeContext = inject(ThemeSymbol);
  if (!themeContext) {
    throw new Error('useTheme debe usarse después de provideTheme');
  }
  return themeContext;
}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>provideTheme</code> provee el tema global y el método <code>toggleTheme</code>.</p>
</li>
<li>
<p><code>useTheme</code> permite a los componentes hijos consumir el tema.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_9">Resumen</h4>
<div class="paragraph">
<p>Los composables son una forma poderosa de optimizar y reutilizar lógica en Vue 3. Mediante el uso de <code>ref</code>, <code>reactive</code>, <code>watch</code>, <code>provide</code>, y <code>inject</code>, se pueden crear funciones flexibles y modulares, mejorando la organización y escalabilidad del código.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_7_integración_de_servicios_y_apis">Módulo 7: Integración de Servicios y APIs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_comunicación_con_apis_rest_usando_axios_y_fetch">Comunicación con APIs REST usando <code>axios</code> y <code>fetch</code></h3>
<div class="paragraph">
<p>La interacción con APIs REST es fundamental en aplicaciones modernas. Vue 3 puede usar librerías como <code>axios</code> y la API <code>fetch</code> nativa del navegador para realizar solicitudes HTTP. Este capítulo explora cómo configurar y utilizar ambos métodos para obtener y enviar datos.</p>
</div>
<div class="sect3">
<h4 id="_instalación_de_axios">Instalación de <code>axios</code></h4>
<div class="paragraph">
<p>Primero, para usar <code>axios</code>, es necesario instalarlo en tu proyecto. Puedes hacerlo mediante npm o yarn.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">npm install axios</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_realizando_solicitudes_con_axios">Realizando solicitudes con <code>axios</code></h4>
<div class="paragraph">
<p><code>axios</code> es una librería basada en promesas que simplifica la realización de solicitudes HTTP y el manejo de respuestas.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de una solicitud GET usando <code>axios</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');

    const fetchPosts = async () =&gt; {
      try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
        posts.value = response.data;
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      }
    };

    fetchPosts();

    return { posts, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se usa <code>axios.get()</code> para realizar una solicitud a una API pública de posts.</p>
</li>
<li>
<p>Los datos obtenidos se almacenan en la variable reactiva <code>posts</code>, mientras que los errores se capturan y se manejan.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_realizando_solicitudes_post_con_axios">Realizando solicitudes POST con <code>axios</code></h4>
<div class="paragraph">
<p><code>axios</code> también permite enviar datos a una API usando solicitudes POST. Este es un ejemplo de cómo hacerlo:</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de una solicitud POST usando <code>axios</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const newPost = ref({ title: '', body: '' });
    const responseMessage = ref('');

    const createPost = async () =&gt; {
      try {
        const response = await axios.post('https://jsonplaceholder.typicode.com/posts', newPost.value);
        responseMessage.value = `Post creado con ID: ${response.data.id}`;
      } catch (error) {
        responseMessage.value = 'Error al crear el post';
        console.error(error);
      }
    };

    return { newPost, responseMessage, createPost };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Crear un nuevo Post&lt;/h2&gt;
      &lt;input v-model="newPost.title" placeholder="Título" /&gt;
      &lt;textarea v-model="newPost.body" placeholder="Contenido"&gt;&lt;/textarea&gt;
      &lt;button @click="createPost"&gt;Enviar&lt;/button&gt;
      &lt;p&gt;{{ responseMessage }}&lt;/p&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>axios.post()</code> se utiliza para enviar datos a la API.</p>
</li>
<li>
<p>Se maneja la respuesta y se muestra un mensaje al usuario.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_la_api_fetch">Uso de la API <code>fetch</code></h4>
<div class="paragraph">
<p>La API <code>fetch</code> es una alternativa nativa a <code>axios</code> que permite realizar solicitudes HTTP. Aunque requiere un poco más de trabajo para manejar las respuestas y errores, es igualmente efectiva.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de una solicitud GET usando <code>fetch</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');

    const fetchPosts = async () =&gt; {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) {
          throw new Error('Error en la respuesta de la red');
        }
        posts.value = await response.json();
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      }
    };

    fetchPosts();

    return { posts, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>fetch()</code> se usa para realizar una solicitud GET a la misma API de posts.</p>
</li>
<li>
<p>Se verifica si la respuesta es correcta con <code>response.ok</code> y se manejan errores adecuadamente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_realizando_solicitudes_post_con_fetch">Realizando solicitudes POST con <code>fetch</code></h4>
<div class="paragraph">
<p>Al igual que con <code>axios</code>, <code>fetch</code> puede usarse para enviar datos a un servidor.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de una solicitud POST usando <code>fetch</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';

export default defineComponent({
  setup() {
    const newPost = ref({ title: '', body: '' });
    const responseMessage = ref('');

    const createPost = async () =&gt; {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(newPost.value),
        });

        if (!response.ok) {
          throw new Error('Error en la respuesta de la red');
        }

        const data = await response.json();
        responseMessage.value = `Post creado con ID: ${data.id}`;
      } catch (error) {
        responseMessage.value = 'Error al crear el post';
        console.error(error);
      }
    };

    return { newPost, responseMessage, createPost };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Crear un nuevo Post&lt;/h2&gt;
      &lt;input v-model="newPost.title" placeholder="Título" /&gt;
      &lt;textarea v-model="newPost.body" placeholder="Contenido"&gt;&lt;/textarea&gt;
      &lt;button @click="createPost"&gt;Enviar&lt;/button&gt;
      &lt;p&gt;{{ responseMessage }}&lt;/p&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p><code>fetch()</code> realiza una solicitud POST, especificando el método y los encabezados necesarios.</p>
</li>
<li>
<p>Se convierte el objeto <code>newPost</code> a JSON antes de enviarlo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_10">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p><strong><code>axios</code></strong>: Una librería simplificada que maneja solicitudes HTTP y respuestas, fácil de usar para gestionar datos.</p>
</li>
<li>
<p><strong><code>fetch</code></strong>: Una API nativa que proporciona flexibilidad, aunque requiere más manejo manual para errores y respuestas.</p>
</li>
<li>
<p>Ambos métodos son útiles para interactuar con APIs REST, dependiendo de las necesidades y preferencias del desarrollador.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_manejo_de_promesas_y_datos_asíncronos_en_componentes">Manejo de promesas y datos asíncronos en componentes</h3>
<div class="paragraph">
<p>El manejo de datos asíncronos es crucial en el desarrollo de aplicaciones modernas. En Vue 3, se pueden gestionar promesas utilizando <code>async/await</code>, lo que permite escribir un código más limpio y fácil de seguir. Este capítulo se centra en cómo manejar datos asíncronos dentro de los componentes.</p>
</div>
<div class="sect3">
<h4 id="_promesas_y_la_api_fetch">Promesas y la API <code>fetch</code></h4>
<div class="paragraph">
<p>Las promesas son un mecanismo para manejar operaciones asíncronas. La API <code>fetch</code>, utilizada para realizar solicitudes HTTP, devuelve una promesa que se resuelve cuando la respuesta está disponible.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo básico de manejo de promesas con <code>fetch</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');

    const fetchPosts = async () =&gt; {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) {
          throw new Error('Error en la respuesta de la red');
        }
        posts.value = await response.json();
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      }
    };

    fetchPosts();

    return { posts, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>La función <code>fetchPosts</code> realiza una solicitud para obtener posts.</p>
</li>
<li>
<p>Se maneja la respuesta y se gestiona cualquier error que ocurra durante la solicitud.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_axios_para_manejar_promesas">Uso de <code>axios</code> para manejar promesas</h4>
<div class="paragraph">
<p><code>axios</code> también maneja promesas y puede simplificar el proceso de solicitudes y respuestas, especialmente con el manejo de errores.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de manejo de promesas usando <code>axios</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');

    const fetchPosts = async () =&gt; {
      try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
        posts.value = response.data;
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      }
    };

    fetchPosts();

    return { posts, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este caso:</div>
<ul>
<li>
<p>La lógica para manejar la respuesta es similar, pero <code>axios</code> simplifica el acceso a los datos a través de <code>response.data</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_de_múltiples_promesas">Manejo de múltiples promesas</h4>
<div class="paragraph">
<p>En situaciones donde necesitas hacer múltiples solicitudes asíncronas, puedes utilizar <code>Promise.all</code> para esperar a que todas se resuelvan.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de múltiples solicitudes con <code>Promise.all</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const comments = ref([]);
    const errorMessage = ref('');

    const fetchData = async () =&gt; {
      try {
        const [postsResponse, commentsResponse] = await Promise.all([
          axios.get('https://jsonplaceholder.typicode.com/posts'),
          axios.get('https://jsonplaceholder.typicode.com/comments'),
        ]);
        posts.value = postsResponse.data;
        comments.value = commentsResponse.data;
      } catch (error) {
        errorMessage.value = 'Error al cargar los datos';
        console.error(error);
      }
    };

    fetchData();

    return { posts, comments, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
      &lt;h2&gt;Comentarios&lt;/h2&gt;
      &lt;ul&gt;
        &lt;li v-for="comment in comments" :key="comment.id"&gt;{{ comment.body }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se realizan dos solicitudes paralelas a la API para obtener posts y comentarios.</p>
</li>
<li>
<p>La respuesta de ambas solicitudes se maneja dentro del mismo bloque <code>try/catch</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_actualización_de_datos_reactivos_en_tiempo_real">Actualización de datos reactivos en tiempo real</h4>
<div class="paragraph">
<p>En algunos casos, puede que necesites actualizar datos reactivos basados en eventos, como la selección de un elemento. Esto puede hacerse con <code>watch</code> para observar cambios en los datos y realizar solicitudes adicionales.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de actualización de datos reactivos:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref, watch } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const selectedPostId = ref(null);
    const postDetails = ref({});
    const errorMessage = ref('');

    watch(selectedPostId, async (newId) =&gt; {
      if (newId) {
        try {
          const response = await axios.get(`https://jsonplaceholder.typicode.com/posts/${newId}`);
          postDetails.value = response.data;
        } catch (error) {
          errorMessage.value = 'Error al cargar los detalles del post';
          console.error(error);
        }
      }
    });

    return { selectedPostId, postDetails, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;select v-model="selectedPostId"&gt;
        &lt;option v-for="post in posts" :key="post.id" :value="post.id"&gt;{{ post.title }}&lt;/option&gt;
      &lt;/select&gt;
      &lt;div v-if="postDetails.title"&gt;
        &lt;h2&gt;{{ postDetails.title }}&lt;/h2&gt;
        &lt;p&gt;{{ postDetails.body }}&lt;/p&gt;
      &lt;/div&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se observa <code>selectedPostId</code> y se realiza una solicitud para obtener detalles del post correspondiente cuando cambia.</p>
</li>
<li>
<p>Esto permite actualizar la interfaz en respuesta a la selección del usuario.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_11">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p>Las promesas son esenciales para manejar datos asíncronos en Vue 3.</p>
</li>
<li>
<p>Se pueden usar <code>async/await</code> para simplificar el manejo de promesas.</p>
</li>
<li>
<p>Tanto <code>axios</code> como <code>fetch</code> permiten realizar solicitudes HTTP, cada uno con sus ventajas y desventajas.</p>
</li>
<li>
<p>Se pueden manejar múltiples promesas y observar cambios en datos reactivos para actualizaciones en tiempo real.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_carga_y_visualización_de_datos_externos">Carga y visualización de datos externos</h3>
<div class="paragraph">
<p>La carga y visualización de datos externos son prácticas comunes en el desarrollo de aplicaciones web. En Vue 3, esto se puede lograr de manera efectiva utilizando <code>axios</code> o la API <code>fetch</code>. Este capítulo cubre cómo cargar datos de diferentes fuentes y mostrarlos en un componente.</p>
</div>
<div class="sect3">
<h4 id="_carga_de_datos_externos_con_fetch">Carga de datos externos con <code>fetch</code></h4>
<div class="paragraph">
<p>La API <code>fetch</code> permite realizar solicitudes a un servidor y obtener datos de forma sencilla. A continuación, se presenta un ejemplo de cómo cargar datos desde una API pública y mostrarlos en un componente.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de carga de datos usando <code>fetch</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref, onMounted } from 'vue';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');

    const fetchPosts = async () =&gt; {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        if (!response.ok) {
          throw new Error('Error en la respuesta de la red');
        }
        posts.value = await response.json();
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      }
    };

    onMounted(fetchPosts); // Cargar datos cuando el componente esté montado

    return { posts, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se utiliza <code>fetch</code> para obtener una lista de posts desde una API pública.</p>
</li>
<li>
<p>La función <code>fetchPosts</code> se llama en el hook <code>onMounted</code> para cargar los datos una vez que el componente se ha montado.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_carga_de_datos_externos_con_axios">Carga de datos externos con <code>axios</code></h4>
<div class="paragraph">
<p><code>axios</code> es otra opción popular para realizar solicitudes HTTP. Proporciona una interfaz más fácil de usar y mejores capacidades de manejo de errores.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de carga de datos usando <code>axios</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref, onMounted } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');

    const fetchPosts = async () =&gt; {
      try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
        posts.value = response.data;
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      }
    };

    onMounted(fetchPosts); // Cargar datos cuando el componente esté montado

    return { posts, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este caso:</div>
<ul>
<li>
<p><code>axios</code> se usa para obtener los datos de la misma API.</p>
</li>
<li>
<p>La respuesta se asigna a la variable reactiva <code>posts</code> para su posterior visualización.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_visualización_de_datos_en_componentes">Visualización de datos en componentes</h4>
<div class="paragraph">
<p>Los datos cargados se pueden mostrar en el DOM utilizando la interpolación de Vue. Puedes utilizar directivas como <code>v-for</code> para iterar sobre las listas y mostrar elementos dinámicamente.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de visualización de datos:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref, onMounted } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const users = ref([]);
    const errorMessage = ref('');

    const fetchUsers = async () =&gt; {
      try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/users');
        users.value = response.data;
      } catch (error) {
        errorMessage.value = 'Error al cargar los usuarios';
        console.error(error);
      }
    };

    onMounted(fetchUsers); // Cargar datos cuando el componente esté montado

    return { users, errorMessage };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Usuarios&lt;/h2&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul&gt;
        &lt;li v-for="user in users" :key="user.id"&gt;{{ user.name }} - {{ user.email }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se carga una lista de usuarios desde una API y se muestran en una lista.</p>
</li>
<li>
<p>Cada usuario se muestra con su nombre y correo electrónico.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_manejo_de_estados_de_carga">Manejo de estados de carga</h4>
<div class="paragraph">
<p>Es útil manejar estados de carga para mejorar la experiencia del usuario. Puedes mostrar un indicador de carga mientras los datos se están obteniendo.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de manejo de estados de carga:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineComponent, ref, onMounted } from 'vue';
import axios from 'axios';

export default defineComponent({
  setup() {
    const posts = ref([]);
    const errorMessage = ref('');
    const isLoading = ref(true); // Estado de carga

    const fetchPosts = async () =&gt; {
      try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
        posts.value = response.data;
      } catch (error) {
        errorMessage.value = 'Error al cargar los posts';
        console.error(error);
      } finally {
        isLoading.value = false; // Finalizar el estado de carga
      }
    };

    onMounted(fetchPosts); // Cargar datos cuando el componente esté montado

    return { posts, errorMessage, isLoading };
  },
  template: `
    &lt;div&gt;
      &lt;h2&gt;Posts&lt;/h2&gt;
      &lt;p v-if="isLoading"&gt;Cargando...&lt;/p&gt;
      &lt;p v-if="errorMessage"&gt;{{ errorMessage }}&lt;/p&gt;
      &lt;ul v-if="!isLoading"&gt;
        &lt;li v-for="post in posts" :key="post.id"&gt;{{ post.title }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  `,
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este caso:</div>
<ul>
<li>
<p>Se agrega un estado <code>isLoading</code> que se establece en <code>true</code> al comienzo y se cambia a <code>false</code> una vez que se completa la carga de datos.</p>
</li>
<li>
<p>Se muestra un mensaje "Cargando&#8230;&#8203;" mientras los datos se obtienen.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_12">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p>La carga de datos externos es esencial en las aplicaciones modernas de Vue.</p>
</li>
<li>
<p>Se pueden utilizar tanto <code>fetch</code> como <code>axios</code> para realizar solicitudes HTTP.</p>
</li>
<li>
<p>La visualización de datos se logra a través de la interpolación de Vue y directivas como <code>v-for</code>.</p>
</li>
<li>
<p>Manejar estados de carga mejora la experiencia del usuario al informar sobre el progreso de la carga de datos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tratamiento_de_errores_y_validaciones_de_api">Tratamiento de errores y validaciones de API</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Manejo de errores:</strong> Es importante capturar errores en las solicitudes de API y proporcionar un manejo adecuado.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  try {
      const response = await axios.get('https://api.example.com/data');
  } catch (error) {
      console.error('Error al cargar los datos:', error);
  }</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Validaciones de API:</strong> Validar la respuesta de la API antes de usar los datos, asegurando que contenga las propiedades esperadas.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  if (response &amp;&amp; response.data) {
      // Procesar los datos
  }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_introducción_a_websockets_en_vue_3">Introducción a WebSockets en Vue 3</h3>
<div class="ulist">
<ul>
<li>
<p><strong>¿Qué son WebSockets?</strong> WebSockets permiten una comunicación bidireccional en tiempo real entre el cliente y el servidor, ideal para aplicaciones que requieren actualizaciones en vivo.</p>
</li>
<li>
<p><strong>Instalación de una librería de WebSockets:</strong> Se puede usar la API nativa de WebSocket o bibliotecas como <code>socket.io</code> para facilitar el trabajo con WebSockets.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npm install socket.io-client</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Conexión a un servidor WebSocket:</strong></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { io } from 'socket.io-client';

  const socket = io('https://socket.example.com');

  socket.on('connect', () =&gt; {
      console.log('Conectado a WebSocket');
  });

  socket.on('message', (data) =&gt; {
      console.log('Mensaje recibido:', data);
  });</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Uso de WebSockets en componentes:</strong> Integrar WebSockets en la lógica del componente para recibir y enviar mensajes.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  setup() {
      const messages = ref([]);

      socket.on('message', (message) =&gt; {
          messages.value.push(message);
      });

      const sendMessage = (message) =&gt; {
          socket.emit('message', message);
      };

      return { messages, sendMessage };
  }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_8_pruebas_en_vue_3">Módulo 8: Pruebas en Vue 3</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_pruebas_unitarias_con_vuetest_utils_y_vitest">Pruebas unitarias con <code>@vue/test-utils</code> y Vitest</h3>
<div class="paragraph">
<p>Las pruebas unitarias son fundamentales para garantizar que los componentes de Vue funcionen correctamente. En este capítulo, aprenderás a utilizar <code>@vue/test-utils</code> junto con Vitest para escribir y ejecutar pruebas unitarias en tus componentes Vue 3.</p>
</div>
<div class="sect3">
<h4 id="_configuración_del_entorno_de_pruebas">Configuración del entorno de pruebas</h4>
<div class="paragraph">
<p>Para comenzar, necesitarás instalar <code>@vue/test-utils</code> y Vitest en tu proyecto. Asegúrate de que estos paquetes estén instalados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">npm install @vue/test-utils vitest --save-dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Luego, puedes crear un archivo de configuración para Vitest en la raíz de tu proyecto.</p>
</div>
<div class="paragraph">
<p><strong>Ejemplo de archivo de configuración <code>vitest.config.ts</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom', // Establecer el entorno de pruebas a jsdom
  },
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto asegura que Vitest use <code>jsdom</code> como entorno para simular un navegador.</p>
</div>
</div>
<div class="sect3">
<h4 id="_escribiendo_pruebas_unitarias">Escribiendo pruebas unitarias</h4>
<div class="paragraph">
<p>Ahora que tienes el entorno de pruebas configurado, puedes escribir pruebas para tus componentes Vue. A continuación se presenta un ejemplo básico.</p>
</div>
<div class="paragraph">
<p><strong>Componente de ejemplo <code>HelloWorld.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;{{ message }}&lt;/h1&gt;
    &lt;button @click="updateMessage"&gt;Actualizar Mensaje&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent, ref } from 'vue';

export default defineComponent({
  setup() {
    const message = ref('Hola Mundo');
    const updateMessage = () =&gt; {
      message.value = '¡Mensaje actualizado!';
    };

    return { message, updateMessage };
  },
});
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Prueba unitaria para <code>HelloWorld.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { mount } from '@vue/test-utils';
import HelloWorld from '@/components/HelloWorld.vue';

describe('HelloWorld.vue', () =&gt; {
  it('muestra el mensaje inicial', () =&gt; {
    const wrapper = mount(HelloWorld);
    expect(wrapper.text()).toContain('Hola Mundo');
  });

  it('actualiza el mensaje al hacer clic en el botón', async () =&gt; {
    const wrapper = mount(HelloWorld);
    await wrapper.find('button').trigger('click');
    expect(wrapper.text()).toContain('¡Mensaje actualizado!');
  });
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>La primera prueba verifica que el mensaje inicial se muestra correctamente.</p>
</li>
<li>
<p>La segunda prueba simula un clic en el botón y verifica que el mensaje se actualiza como se esperaba.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejecutando_pruebas">Ejecutando pruebas</h4>
<div class="paragraph">
<p>Para ejecutar tus pruebas, simplemente usa el siguiente comando en la terminal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">npx vitest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto ejecutará todas las pruebas en tu proyecto y mostrará los resultados en la consola.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pruebas_de_componentes_con_propiedades_props">Pruebas de componentes con propiedades (<code>props</code>)</h4>
<div class="paragraph">
<p>También puedes probar componentes que aceptan propiedades. A continuación se presenta un ejemplo de un componente que usa propiedades.</p>
</div>
<div class="paragraph">
<p><strong>Componente de ejemplo <code>Greeting.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;Hola, {{ name }}!&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';

export default defineComponent({
  props: {
    name: {
      type: String,
      required: true,
    },
  },
});
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Prueba unitaria para <code>Greeting.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { mount } from '@vue/test-utils';
import Greeting from '@/components/Greeting.vue';

describe('Greeting.vue', () =&gt; {
  it('muestra el saludo con el nombre pasado como prop', () =&gt; {
    const wrapper = mount(Greeting, {
      props: { name: 'Juan' },
    });
    expect(wrapper.text()).toContain('Hola, Juan!');
  });
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este caso:</div>
<ul>
<li>
<p>Se pasa la propiedad <code>name</code> al componente y se verifica que se muestre correctamente en el DOM.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_pruebas_de_métodos_y_estados_reactivos">Pruebas de métodos y estados reactivos</h4>
<div class="paragraph">
<p>También puedes probar métodos y estados reactivos en tus componentes. Aquí tienes un ejemplo más complejo.</p>
</div>
<div class="paragraph">
<p><strong>Componente de ejemplo <code>Counter.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Cuenta: {{ count }}&lt;/p&gt;
    &lt;button @click="increment"&gt;Incrementar&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent, ref } from 'vue';

export default defineComponent({
  setup() {
    const count = ref(0);
    const increment = () =&gt; {
      count.value++;
    };

    return { count, increment };
  },
});
&lt;/script&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Prueba unitaria para <code>Counter.vue</code>:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">import { mount } from '@vue/test-utils';
import Counter from '@/components/Counter.vue';

describe('Counter.vue', () =&gt; {
  it('muestra la cuenta inicial', () =&gt; {
    const wrapper = mount(Counter);
    expect(wrapper.text()).toContain('Cuenta: 0');
  });

  it('incrementa la cuenta al hacer clic en el botón', async () =&gt; {
    const wrapper = mount(Counter);
    await wrapper.find('button').trigger('click');
    expect(wrapper.text()).toContain('Cuenta: 1');
  });
});</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se prueba el estado reactivo <code>count</code> y se verifica que se actualiza correctamente cuando se hace clic en el botón.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_13">Resumen</h4>
<div class="ulist">
<ul>
<li>
<p>Las pruebas unitarias son esenciales para asegurar la calidad del código en aplicaciones Vue.</p>
</li>
<li>
<p>Puedes utilizar <code>@vue/test-utils</code> y Vitest para escribir y ejecutar pruebas de componentes.</p>
</li>
<li>
<p>Puedes probar tanto la representación de la interfaz como la lógica interna de los componentes.</p>
</li>
<li>
<p>Asegúrate de cubrir diferentes casos de uso, incluyendo propiedades, métodos y estados reactivos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_simulación_de_eventos_y_cambios_de_estado">Simulación de eventos y cambios de estado</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Simulación de eventos:</strong> Utiliza el método <code>trigger</code> para simular eventos como clics o entradas de texto.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  it('emits an event when button is clicked', async () =&gt; {
      const wrapper = mount(MyComponent);
      await wrapper.find('button').trigger('click');
      expect(wrapper.emitted()).toHaveProperty('my-event');
  });</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cambios de estado:</strong> Asegúrate de que los métodos de cambio de estado se comporten como se espera.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  it('updates the data when input changes', async () =&gt; {
      const wrapper = mount(MyComponent);
      await wrapper.find('input').setValue('Nuevo Valor');
      expect(wrapper.vm.inputValue).toBe('Nuevo Valor');
  });</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejecutar_pruebas">Ejecutar pruebas</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Ejecutar pruebas unitarias:</strong> Usa el siguiente comando para ejecutar todas las pruebas en tu proyecto.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npx vitest</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Visualización de resultados:</strong> Vitest mostrará un resumen de las pruebas pasadas y fallidas, así como cualquier error encontrado durante la ejecución.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_pruebas_de_pinia_y_vue_router_en_componentes_con_vitest">Pruebas de Pinia y Vue Router en componentes con Vitest</h3>

</div>
<div class="sect2">
<h3 id="_pruebas_de_pinia">Pruebas de Pinia</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Configuración de Pinia en pruebas:</strong> Para probar componentes que utilizan Pinia, primero debes crear una store de prueba.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { createPinia } from 'pinia';
  import { mount } from '@vue/test-utils';
  import MyComponent from '@/components/MyComponent.vue';

  const pinia = createPinia();
  const wrapper = mount(MyComponent, {
      global: {
          plugins: [pinia]
      }
  });</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Ejemplo de prueba de una acción de Pinia:</strong> Verifica que una acción en tu store cambie el estado correctamente.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { defineStore } from 'pinia';

  const useMyStore = defineStore('myStore', {
      state: () =&gt; ({ count: 0 }),
      actions: {
          increment() {
              this.count++;
          }
      }
  });

  test('increments count', () =&gt; {
      const store = useMyStore();
      store.increment();
      expect(store.count).toBe(1);
  });</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pruebas_de_vue_router">Pruebas de Vue Router</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Configuración de Vue Router en pruebas:</strong> Al probar componentes que dependen de Vue Router, debes configurar un router de prueba.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { createRouter, createWebHistory } from 'vue-router';

  const router = createRouter({
      history: createWebHistory(),
      routes: [
          { path: '/', component: MyComponent },
          { path: '/about', component: AboutComponent }
      ]
  });

  const wrapper = mount(MyComponent, {
      global: {
          plugins: [router]
      }
  });</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Ejemplo de prueba de navegación:</strong> Verifica que la navegación entre rutas funcione correctamente.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  test('navigates to about page', async () =&gt; {
      const wrapper = mount(MyComponent, {
          global: {
              plugins: [router]
          }
      });
      await wrapper.find('a[href="/about"]').trigger('click');
      expect(wrapper.html()).toContain('About Component Content');
  });</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_combinando_pinia_y_vue_router">Combinando Pinia y Vue Router</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Prueba de un componente que utiliza tanto Pinia como Vue Router:</strong> Asegúrate de que ambos funcionan juntos en una prueba.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  import { createPinia } from 'pinia';

  const pinia = createPinia();
  const wrapper = mount(MyComponent, {
      global: {
          plugins: [pinia, router]
      }
  });

  test('checks interaction between store and router', async () =&gt; {
      const store = useMyStore();
      store.increment();
      await wrapper.find('a[href="/about"]').trigger('click');
      expect(store.count).toBe(1);
      expect(wrapper.html()).toContain('About Component Content');
  });</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ejecutar_pruebas_2">Ejecutar pruebas</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Ejecutar las pruebas:</strong> Usa el siguiente comando para ejecutar todas las pruebas, asegurándote de que tanto las pruebas de Pinia como las de Vue Router se ejecuten correctamente.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">  npx vitest</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Resultados:</strong> Vitest mostrará un resumen de las pruebas pasadas y fallidas, proporcionando información sobre cualquier problema encontrado durante la ejecución.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_buenas_prácticas_para_pruebas_unitarias">Buenas prácticas para pruebas unitarias</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Nombres claros:</strong> Usa nombres descriptivos para las pruebas que expliquen su propósito.</p>
</li>
<li>
<p><strong>Mantener pruebas aisladas:</strong> Cada prueba debe ser independiente y no depender de otras pruebas para funcionar.</p>
</li>
<li>
<p><strong>Pruebas de integración:</strong> Realiza pruebas que combinen la lógica de tu store con la navegación para asegurar que todo funcione correctamente en conjunto.</p>
</li>
<li>
<p><strong>Documentación:</strong> Asegúrate de documentar tus pruebas, especificando qué aspectos de la lógica y la interacción estás verificando.</p>
</li>
<li>
<p><strong>Revisar y actualizar pruebas regularmente:</strong> A medida que la aplicación evoluciona, asegúrate de que las pruebas se mantengan actualizadas y cubran todos los casos de uso relevantes.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_pruebas_de_integración_para_asegurar_la_funcionalidad_completa">Pruebas de integración para asegurar la funcionalidad completa</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Definición de pruebas de integración:</strong> Aseguran que diferentes partes de la aplicación funcionen correctamente juntas.</p>
</li>
<li>
<p><strong>Ejemplo de prueba de integración:</strong> Monta varios componentes y prueba la interacción entre ellos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  test('should interact with child component', async () =&gt; {
      const wrapper = mount(ParentComponent);
      await wrapper.find('button').trigger('click');
      expect(wrapper.findComponent(ChildComponent).text()).toContain('Texto actualizado');
  });</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pruebas de flujo completo:</strong> Asegúrate de que la funcionalidad completa se prueba, desde la entrada del usuario hasta la visualización de datos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  test('full flow test', async () =&gt; {
      const wrapper = mount(MyForm);
      await wrapper.find('input').setValue('Nuevo valor');
      await wrapper.find('form').trigger('submit');
      expect(wrapper.text()).toContain('Datos enviados');
  });</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_9_optimización_de_rendimiento">Módulo 9: Optimización de Rendimiento</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_code_splitting_y_lazy_loaging">Code splitting y lazy loaging</h3>
<div class="ulist">
<ul>
<li>
<p><strong>¿Qué es el code splitting?</strong> Es una técnica que permite dividir el código de una aplicación en varios archivos que se cargan bajo demanda, mejorando el tiempo de carga inicial.</p>
</li>
<li>
<p><strong>Implementación de code splitting en Vue:</strong> Usa funciones de importación dinámica para dividir el código.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  const AsyncComponent = () =&gt; import('./components/AsyncComponent.vue');

  export default {
      components: {
          AsyncComponent
      }
  };</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uso_de_keep_alive_para_optimizar_el_cacheo_de_componentes">Uso de <code>keep-alive</code> para optimizar el cacheo de componentes</h3>
<div class="ulist">
<ul>
<li>
<p><strong><code>&lt;keep-alive&gt;</code>:</strong> Componente que permite cachear componentes, mejorando el rendimiento al evitar su re-renderización.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  &lt;template&gt;
      &lt;keep-alive&gt;
          &lt;router-view /&gt;
      &lt;/keep-alive&gt;
  &lt;/template&gt;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Condiciones para cachear componentes:</strong> Se puede utilizar la propiedad <code>include</code> y <code>exclude</code> para especificar qué componentes cachear.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  &lt;keep-alive include="ComponentA,ComponentB"&gt;
      &lt;router-view /&gt;
  &lt;/keep-alive&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lazy_loading_en_rutas_y_componentes">Lazy loading en rutas y componentes</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Lazy loading en rutas:</strong> Implementar lazy loaging en Vue Router para cargar solo las rutas necesarias.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  const routes = [
      {
          path: '/about',
          component: () =&gt; import('./views/About.vue')
      }
  ];</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Lazy loading en componentes:</strong> Similar al code splitting, permite cargar componentes solo cuando son necesarios.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">  const LazyComponent = () =&gt; import('./components/LazyComponent.vue');</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_herramientas_para_la_optimización_de_performance_en_vue">Herramientas para la optimización de performance en Vue</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Vue Devtools:</strong> Herramienta esencial para analizar el rendimiento de la aplicación y detectar cuellos de botella.</p>
</li>
<li>
<p><strong>Lighthouse:</strong> Utiliza esta herramienta para auditar el rendimiento de la aplicación web, proporcionando métricas y sugerencias para mejorar.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_buenas_prácticas_para_aplicaciones_vue_eficientes">Buenas prácticas para aplicaciones Vue eficientes</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Minimizar el uso de watchers:</strong> Prefiere el uso de <code>computed</code> sobre <code>watch</code> siempre que sea posible, ya que son más eficientes.</p>
</li>
<li>
<p><strong>Evitar mutaciones directas:</strong> Utiliza métodos para cambiar el estado y evita mutaciones directas en objetos reactivos.</p>
</li>
<li>
<p><strong>Optimizar la estructura de componentes:</strong> Mantén los componentes pequeños y enfocados, favoreciendo la reutilización.</p>
</li>
<li>
<p><strong>Utilizar <code>v-if</code> y <code>v-show</code> adecuadamente:</strong> Usa <code>v-if</code> para elementos que cambian dinámicamente y <code>v-show</code> para elementos que están presentes pero ocultos.</p>
</li>
<li>
<p><strong>Páginas estáticas con Nuxt.js:</strong> Si es posible, utiliza Nuxt.js para renderizar páginas estáticas y mejorar la carga inicial.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_10_despliegue_y_construcción_para_producción">Módulo 10: Despliegue y Construcción para Producción</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_preparación_de_la_aplicación_para_producción">Preparación de la aplicación para producción</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Verificación de configuraciones:</strong> Asegúrate de que la configuración de la aplicación sea adecuada para el entorno de producción (por ejemplo, variables de entorno).</p>
</li>
<li>
<p><strong>Eliminación de logs y datos de desarrollo:</strong> Asegúrate de eliminar cualquier código relacionado con el desarrollo, como logs innecesarios.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_construcción_y_minificación_del_proyecto_vue">Construcción y minificación del proyecto Vue</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Construcción del proyecto:</strong> Utiliza el comando de Vue CLI para crear una versión optimizada de la aplicación.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">    npm run build</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Minificación de archivos:</strong> La construcción del proyecto también incluye la minificación automática de archivos typescript y CSS, reduciendo su tamaño.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_configuración_para_servidores_estáticos_netlify_vercel_github_pages">Configuración para servidores estáticos (Netlify, Vercel, GitHub Pages)</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Despliegue en Netlify:</strong></p>
<div class="ulist">
<ul>
<li>
<p>Conéctate a tu repositorio en GitHub y configura el despliegue automático.</p>
</li>
<li>
<p>Configura la carpeta de publicación como <code>dist</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Despliegue en Vercel:</strong></p>
<div class="ulist">
<ul>
<li>
<p>Instala la CLI de Vercel y despliega usando el comando:</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">    vercel</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Despliegue en GitHub Pages:</strong></p>
<div class="ulist">
<ul>
<li>
<p>Configura el <code>vue.config.js</code> para que la aplicación se publique correctamente.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">    module.exports = {
        publicPath: process.env.NODE_ENV === 'production' ? '/nombre-del-repositorio/' : '/'
    };</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Usa el siguiente comando para desplegar:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">    npm run deploy</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_despliegue_de_aplicaciones_en_entornos_de_producción">Despliegue de aplicaciones en entornos de producción</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Configuraciones de seguridad:</strong> Asegúrate de que la aplicación esté segura antes del despliegue, incluyendo la configuración de HTTPS.</p>
</li>
<li>
<p><strong>Uso de CDN:</strong> Considera usar un CDN para mejorar la entrega de contenido y reducir la latencia.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_monitorización_y_mantenimiento_post_despliegue">Monitorización y mantenimiento post-despliegue</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Herramientas de monitorización:</strong> Implementa herramientas como Google Analytics o Sentry para monitorizar el rendimiento y los errores de la aplicación en producción.</p>
</li>
<li>
<p><strong>Actualizaciones periódicas:</strong> Realiza actualizaciones de seguridad y mantenimiento regularmente para asegurar que la aplicación siga funcionando correctamente.</p>
</li>
<li>
<p><strong>Feedback del usuario:</strong> Recoge comentarios de los usuarios para identificar áreas de mejora y nuevas características.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_11_librerías_y_recursos_adicionales">Módulo 11: Librerías y Recursos Adicionales</h2>
<div class="sectionbody">
<div class="olist arabic">
<div class="title">Librerías de Terceros Más Usadas con Vue.js</div>
<ol class="arabic">
<li>
<p>Vue Router - Manejo de rutas. <a href="https://router.vuejs.org">link</a></p>
</li>
<li>
<p>Vuex - Manejo del estado global. <a href="https://vuex.vuejs.org">link</a></p>
</li>
<li>
<p>Vuetify - Componentes UI basados en Material Design. <a href="https://vuetifyjs.com">link</a></p>
</li>
<li>
<p>Element UI - Marco de componentes UI para aplicaciones de escritorio. <a href="https://element.eleme.io">link</a></p>
</li>
<li>
<p>Axios - Solicitudes HTTP. <a href="https://axios-http.com">link</a></p>
</li>
<li>
<p>Vue-i18n - Internacionalización. <a href="https://kazupon.github.io/vue-i18n">link</a></p>
</li>
<li>
<p>Vuex ORM - Manejo de datos relacionales en Vuex. <a href="https://vuex-orm.github.io/vuex-orm">link</a></p>
</li>
<li>
<p>VeeValidate - Validación de formularios. <a href="https://vee-validate.logaretm.com">link</a></p>
</li>
<li>
<p>Vue Apollo - Integración de GraphQL. <a href="https://vue-apollo.netlify.app">link</a></p>
</li>
<li>
<p>Nuxt.js - Framework para aplicaciones universales. <a href="https://nuxtjs.org">link</a></p>
</li>
<li>
<p>BootstrapVue - Integración de Bootstrap con Vue. <a href="https://bootstrap-vue.org">link</a></p>
</li>
<li>
<p>Vue Toastification - Notificaciones toast. <a href="https://github.com/Maronato/vue-toastification">link</a></p>
</li>
<li>
<p>Chart.js (con vue-chartjs) - Gráficas y visualizaciones. <a href="https://vue-chartjs.org">link</a></p>
</li>
<li>
<p>Vue Draggable - Para implementar listas arrastrables. <a href="https://github.com/SortableJS/Vue.Draggable">link</a></p>
</li>
<li>
<p>Vue Lazyload - Carga diferida de imágenes. <a href="https://github.com/hilongjw/vue-lazyload">link</a></p>
</li>
<li>
<p>Vue Multiselect - Componente de selección múltiple. <a href="https://vue-multiselect.js.org">link</a></p>
</li>
<li>
<p>Vue Sweetalert2 - Dialogs y alertas personalizables. <a href="https://sweetalert2.github.io">link</a></p>
</li>
<li>
<p>Quasar Framework - Framework para aplicaciones en múltiples plataformas. <a href="https://quasar.dev">link</a></p>
</li>
<li>
<p>Vue Formulate - Manejo avanzado de formularios. <a href="https://vueformulate.com">link</a></p>
</li>
<li>
<p>Vue Snotify - Notificaciones de manera sencilla. <a href="https://github.com/artemsky/vue-snotify">link</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-10-31 17:16:57 +0100
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>